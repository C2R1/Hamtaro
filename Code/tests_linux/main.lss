
main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000003e  00800100  000019aa  00001a3e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000019aa  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000000b2  0080013e  0080013e  00001a7c  2**0
                  ALLOC
  3 .stab         0000462c  00000000  00000000  00001a7c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00001c0b  00000000  00000000  000060a8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 e1 00 	jmp	0x1c2	; 0x1c2 <__ctors_end>
       4:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
       8:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
       c:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
      10:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
      14:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
      18:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
      1c:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
      20:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
      24:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
      28:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
      2c:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
      30:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
      34:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
      38:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
      3c:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
      40:	0c 94 de 05 	jmp	0xbbc	; 0xbbc <__vector_16>
      44:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
      48:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
      4c:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
      50:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
      54:	0c 94 00 01 	jmp	0x200	; 0x200 <__vector_21>
      58:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
      5c:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
      60:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
      64:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
      68:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
      6c:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
      70:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
      74:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
      78:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
      7c:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
      80:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
      84:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
      88:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>

0000008c <Melody_Tof_count>:
      8c:	14 13 13 11 11 10 0f 0e 0e 0d 0c 0b 0b 0a 0a 09     ................
      9c:	09 09 08 08 07 07 06 06 06 06 05 05 05 05 80 40     ...............@
      ac:	c0 20                                               . 

000000ae <Melody_Sub_Time>:
      ae:	00 30 c0 0e ca 2e e8 4c b2 ca 22 00 72 08 98 20     .0.....L..".r.. 
      be:	9e e6 88 d8 5a b8 00 14 68 e0 00 14 68 e0 00 00     ....Z...h...h...
	...

000000d0 <Melody_Kongnamul>:
      d0:	05 0a 14 29 3f 53 7d 08 10 20                       ...)?S}.. 

000000da <T1SOL>:
      da:	00 1e                                               ..

000000dc <T1SOLS>:
      dc:	01 1e                                               ..

000000de <T1RA>:
      de:	02 1e                                               ..

000000e0 <T1RAS>:
      e0:	03 1e                                               ..

000000e2 <T1SI>:
      e2:	04 1e                                               ..

000000e4 <T2DO>:
      e4:	05 1e                                               ..

000000e6 <T2DOS>:
      e6:	06 1e                                               ..

000000e8 <T2RE>:
      e8:	07 1e                                               ..

000000ea <T2RES>:
      ea:	08 1e                                               ..

000000ec <T2MI>:
      ec:	09 1e                                               ..

000000ee <T2PA>:
      ee:	0a 1e                                               ..

000000f0 <T2PAS>:
      f0:	0b 1e                                               ..

000000f2 <T2SOL>:
      f2:	0c 1e                                               ..

000000f4 <T2SOLS>:
      f4:	0d 1e                                               ..

000000f6 <T2RA>:
      f6:	0e 1e                                               ..

000000f8 <T2RAS>:
      f8:	0f 1e                                               ..

000000fa <T2SI>:
      fa:	10 1e                                               ..

000000fc <T3DO>:
      fc:	11 1e                                               ..

000000fe <T3DOS>:
      fe:	12 1e                                               ..

00000100 <T3RE>:
     100:	13 1e                                               ..

00000102 <T3RES>:
     102:	14 1e                                               ..

00000104 <T3MI>:
     104:	15 1e                                               ..

00000106 <T3PA>:
     106:	16 1e                                               ..

00000108 <T3PAS>:
     108:	17 1e                                               ..

0000010a <T3SOL>:
     10a:	18 1e                                               ..

0000010c <T3SOLS>:
     10c:	19 1e                                               ..

0000010e <T3RA>:
     10e:	1a 1e                                               ..

00000110 <T3RAS>:
     110:	1b 1e                                               ..

00000112 <T3SI>:
     112:	1c 1e                                               ..

00000114 <T4DO>:
     114:	1d 1e                                               ..

00000116 <CRES>:
     116:	20 1e                                                .

00000118 <RHYTHM_32>:
	...

00000119 <RHYTHM_16>:
     119:	01                                                  .

0000011a <RHYTHM_8_2>:
     11a:	02                                                  .

0000011b <RHYTHM_4_2>:
     11b:	03                                                  .

0000011c <RHYTHM_DOT_4>:
     11c:	04                                                  .

0000011d <RHYTHM_2_2>:
     11d:	05                                                  .

0000011e <RHYTHM_DOT_2>:
     11e:	06                                                  .

0000011f <RHYTHM_DOT_32>:
     11f:	07                                                  .

00000120 <RHYTHM_DOT_16>:
     120:	08                                                  .

00000121 <RHYTHM_DOT_8>:
     121:	09                                                  .

00000122 <MELODY_1>:
     122:	09 0c 09 1e 0e 0a 00 00 00 00 00 00 00 00           ..............

00000130 <RHYTHM_EX_1>:
     130:	12 12 12 12 12 00 00 00 00 00 00 00 00              .............

0000013d <MELODY_2>:
     13d:	09 0c 09 0e 1e 0a 07 00 02 04 05 07 04 05 1e        ...............

0000014c <RHYTHM_EX_2>:
     14c:	02 02 02 02 02 02 01 01 01 01 01 01 03 00           ..............

0000015a <MELODY_3>:
     15a:	02 03 02 1e                                         ....

0000015e <RHYTHM_EX_3>:
     15e:	11 31 11                                            .1.

00000161 <MELODY_4>:
     161:	00 02 04 05 07 08 09 04 07 02 05 20 04 03 04 20     ........... ... 
     171:	0a 06 09 04 07 20 05 04 05 1e                       ..... ....

0000017b <RHYTHM_EX_4>:
     17b:	07 07 07 07 07 07 09 07 09 07 09 07 08 08 08 01     ................
     18b:	09 07 09 07 09 07 08 08 08                          .........

00000194 <MELODY_5>:
     194:	02 03 02 1e                                         ....

00000198 <RHYTHM_EX_5>:
     198:	11 31 11                                            .1.

0000019b <MELODY_6>:
     19b:	02 07 02 20 1e                                      ... .

000001a0 <RHYTHM_EX_6>:
     1a0:	02 02 01 04                                         ....

000001a4 <MELODY_7>:
     1a4:	1d 18 1d 1e                                         ....

000001a8 <RHYTHM_EX_7>:
     1a8:	08 08 08                                            ...

000001ab <MELODY_8>:
     1ab:	0b 03 0b 20 1e                                      ... .

000001b0 <RHYTHM_EX_8>:
     1b0:	02 01 02 08                                         ....

000001b4 <MELODY_9>:
     1b4:	07 14 1e                                            ...

000001b7 <RHYTHM_EX_9>:
     1b7:	01 00                                               ..

000001b9 <MELODY_10>:
     1b9:	1d 18 1d 20 1e                                      ... .

000001be <RHYTHM_EX_10>:
     1be:	08 08 08 05                                         ....

000001c2 <__ctors_end>:
     1c2:	11 24       	eor	r1, r1
     1c4:	1f be       	out	0x3f, r1	; 63
     1c6:	cf ef       	ldi	r28, 0xFF	; 255
     1c8:	d0 e1       	ldi	r29, 0x10	; 16
     1ca:	de bf       	out	0x3e, r29	; 62
     1cc:	cd bf       	out	0x3d, r28	; 61

000001ce <__do_copy_data>:
     1ce:	11 e0       	ldi	r17, 0x01	; 1
     1d0:	a0 e0       	ldi	r26, 0x00	; 0
     1d2:	b1 e0       	ldi	r27, 0x01	; 1
     1d4:	ea ea       	ldi	r30, 0xAA	; 170
     1d6:	f9 e1       	ldi	r31, 0x19	; 25
     1d8:	02 c0       	rjmp	.+4      	; 0x1de <__do_copy_data+0x10>
     1da:	05 90       	lpm	r0, Z+
     1dc:	0d 92       	st	X+, r0
     1de:	ae 33       	cpi	r26, 0x3E	; 62
     1e0:	b1 07       	cpc	r27, r17
     1e2:	d9 f7       	brne	.-10     	; 0x1da <__do_copy_data+0xc>

000001e4 <__do_clear_bss>:
     1e4:	11 e0       	ldi	r17, 0x01	; 1
     1e6:	ae e3       	ldi	r26, 0x3E	; 62
     1e8:	b1 e0       	ldi	r27, 0x01	; 1
     1ea:	01 c0       	rjmp	.+2      	; 0x1ee <.do_clear_bss_start>

000001ec <.do_clear_bss_loop>:
     1ec:	1d 92       	st	X+, r1

000001ee <.do_clear_bss_start>:
     1ee:	a0 3f       	cpi	r26, 0xF0	; 240
     1f0:	b1 07       	cpc	r27, r17
     1f2:	e1 f7       	brne	.-8      	; 0x1ec <.do_clear_bss_loop>
     1f4:	0e 94 ca 0c 	call	0x1994	; 0x1994 <main>
     1f8:	0c 94 d3 0c 	jmp	0x19a6	; 0x19a6 <_exit>

000001fc <__bad_interrupt>:
     1fc:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000200 <__vector_21>:
////////////////////////////////////////////////////////////
/////- Function -///////////////////////////////////////////
////////////////////////////////////////////////////////////

SIGNAL(SIG_ADC)
{
     200:	1f 92       	push	r1
     202:	0f 92       	push	r0
     204:	0f b6       	in	r0, 0x3f	; 63
     206:	0f 92       	push	r0
     208:	11 24       	eor	r1, r1
     20a:	8f 93       	push	r24
    ADCData[0] = inp(ADCL);
     20c:	84 b1       	in	r24, 0x04	; 4
     20e:	80 93 e5 01 	sts	0x01E5, r24
    ADCData[1] = inp(ADCH);
     212:	85 b1       	in	r24, 0x05	; 5
     214:	80 93 e6 01 	sts	0x01E6, r24
    ADCComplete = 1;	//ADC 완료 플래그
     218:	81 e0       	ldi	r24, 0x01	; 1
     21a:	80 93 99 01 	sts	0x0199, r24
}
     21e:	8f 91       	pop	r24
     220:	0f 90       	pop	r0
     222:	0f be       	out	0x3f, r0	; 63
     224:	0f 90       	pop	r0
     226:	1f 90       	pop	r1
     228:	18 95       	reti

0000022a <ClkTickFunc>:
	static u08 tickcnt  = 0;
	static CLKTickCnt = 0;	
  	static u08 sec6cnt = 0;
  	
 
  	tickcnt++;
     22a:	80 91 51 01 	lds	r24, 0x0151
     22e:	8f 5f       	subi	r24, 0xFF	; 255
     230:	80 93 51 01 	sts	0x0151, r24
   	
	if(tickcnt == 16)
     234:	80 31       	cpi	r24, 0x10	; 16
     236:	b9 f4       	brne	.+46     	; 0x266 <ClkTickFunc+0x3c>
	{									// 64 * 16 = 1024uSec
		tickcnt = 0;			
     238:	10 92 51 01 	sts	0x0151, r1
		CLKTickCnt++;
     23c:	80 91 4f 01 	lds	r24, 0x014F
     240:	90 91 50 01 	lds	r25, 0x0150
     244:	01 96       	adiw	r24, 0x01	; 1
     246:	90 93 50 01 	sts	0x0150, r25
     24a:	80 93 4f 01 	sts	0x014F, r24
	    
	    
		fMicSample = 1;
     24e:	21 e0       	ldi	r18, 0x01	; 1
     250:	20 93 6a 01 	sts	0x016A, r18
        
		if(CLKTickCnt == 2)
     254:	82 30       	cpi	r24, 0x02	; 2
     256:	91 05       	cpc	r25, r1
     258:	31 f4       	brne	.+12     	; 0x266 <ClkTickFunc+0x3c>
		{					// 1024 *	2	=	2,048
		    fcdsSample = 1;
     25a:	20 93 bb 01 	sts	0x01BB, r18
			CLKTickCnt = 0;
     25e:	10 92 50 01 	sts	0x0150, r1
     262:	10 92 4f 01 	sts	0x014F, r1
     266:	08 95       	ret

00000268 <REPosition>:

// Remocon

void REPosition(u08 repos)
{
	switch(repos)
     268:	83 30       	cpi	r24, 0x03	; 3
     26a:	99 f0       	breq	.+38     	; 0x292 <REPosition+0x2a>
     26c:	84 30       	cpi	r24, 0x04	; 4
     26e:	28 f4       	brcc	.+10     	; 0x27a <REPosition+0x12>
     270:	81 30       	cpi	r24, 0x01	; 1
     272:	41 f0       	breq	.+16     	; 0x284 <REPosition+0x1c>
     274:	82 30       	cpi	r24, 0x02	; 2
     276:	d1 f4       	brne	.+52     	; 0x2ac <REPosition+0x44>
     278:	0a c0       	rjmp	.+20     	; 0x28e <REPosition+0x26>
     27a:	84 30       	cpi	r24, 0x04	; 4
     27c:	61 f0       	breq	.+24     	; 0x296 <REPosition+0x2e>
     27e:	85 30       	cpi	r24, 0x05	; 5
     280:	a9 f4       	brne	.+42     	; 0x2ac <REPosition+0x44>
     282:	0f c0       	rjmp	.+30     	; 0x2a2 <REPosition+0x3a>
	{
		case 1:		IR_RX_PIN = IR_TX_PIN = 0;
     284:	10 92 56 01 	sts	0x0156, r1
     288:	10 92 75 01 	sts	0x0175, r1
				break;
     28c:	08 95       	ret
		case 2:		IR_RX_PIN = IR_TX_PIN = 1;
     28e:	81 e0       	ldi	r24, 0x01	; 1
     290:	03 c0       	rjmp	.+6      	; 0x298 <REPosition+0x30>
				break;
		case 3:		IR_RX_PIN = IR_TX_PIN = 2;
     292:	82 e0       	ldi	r24, 0x02	; 2
     294:	01 c0       	rjmp	.+2      	; 0x298 <REPosition+0x30>
				break;
		case 4:		IR_RX_PIN = IR_TX_PIN = 3;
     296:	83 e0       	ldi	r24, 0x03	; 3
     298:	80 93 56 01 	sts	0x0156, r24
     29c:	80 93 75 01 	sts	0x0175, r24
				break;
     2a0:	08 95       	ret
		case 5:		IR_RX_PIN = IR_TX_PIN = 4;
     2a2:	84 e0       	ldi	r24, 0x04	; 4
     2a4:	80 93 56 01 	sts	0x0156, r24
     2a8:	80 93 75 01 	sts	0x0175, r24
     2ac:	08 95       	ret

000002ae <SetSpeaker>:
///////////////////////////////////////////////////////
//멜로디 관련함수

void SetSpeaker(u08 pos,u08 *pMel,u08 *pKong)
{
    Mel = pMel;
     2ae:	60 93 76 01 	sts	0x0176, r22
     2b2:	70 93 77 01 	sts	0x0177, r23
    Kon = pKong;
     2b6:	40 93 eb 01 	sts	0x01EB, r20
     2ba:	50 93 ec 01 	sts	0x01EC, r21
	
	m_nPos_Speaker = pos;		
     2be:	80 93 57 01 	sts	0x0157, r24
    
	pM_ = pM_refrash = Mel;			
     2c2:	60 93 6f 01 	sts	0x016F, r22
     2c6:	70 93 70 01 	sts	0x0170, r23
     2ca:	60 93 c1 01 	sts	0x01C1, r22
     2ce:	70 93 c2 01 	sts	0x01C2, r23
	pK_ = pK_refrash =  Kon;		
     2d2:	40 93 71 01 	sts	0x0171, r20
     2d6:	50 93 72 01 	sts	0x0172, r21
     2da:	40 93 e8 01 	sts	0x01E8, r20
     2de:	50 93 e9 01 	sts	0x01E9, r21
	OvfCount 	= pgm_read_byte(&Melody_Tof_count[pgm_read_byte(pM_ )]);
     2e2:	fb 01       	movw	r30, r22
     2e4:	84 91       	lpm	r24, Z+
     2e6:	90 e0       	ldi	r25, 0x00	; 0
     2e8:	fc 01       	movw	r30, r24
     2ea:	e4 57       	subi	r30, 0x74	; 116
     2ec:	ff 4f       	sbci	r31, 0xFF	; 255
     2ee:	e4 91       	lpm	r30, Z+
     2f0:	e0 93 bc 01 	sts	0x01BC, r30
	SubTimeValue= pgm_read_byte(&Melody_Sub_Time[pgm_read_byte(pM_)]);	
     2f4:	82 55       	subi	r24, 0x52	; 82
     2f6:	9f 4f       	sbci	r25, 0xFF	; 255
     2f8:	fc 01       	movw	r30, r24
     2fa:	84 91       	lpm	r24, Z+
     2fc:	80 93 81 01 	sts	0x0181, r24
	
	MelImpect = pgm_read_byte(pK_);
     300:	fa 01       	movw	r30, r20
     302:	e4 91       	lpm	r30, Z+
     304:	e0 93 46 01 	sts	0x0146, r30
	KongCount 	= pgm_read_byte(&Melody_Kongnamul[(0x0f&(pgm_read_byte(pK_)))]);
     308:	f0 e0       	ldi	r31, 0x00	; 0
     30a:	ef 70       	andi	r30, 0x0F	; 15
     30c:	f0 70       	andi	r31, 0x00	; 0
     30e:	e0 53       	subi	r30, 0x30	; 48
     310:	ff 4f       	sbci	r31, 0xFF	; 255
     312:	e4 91       	lpm	r30, Z+
     314:	e0 93 ee 01 	sts	0x01EE, r30
    
    
	PLAYMELODY();		
     318:	80 91 7c 01 	lds	r24, 0x017C
     31c:	88 60       	ori	r24, 0x08	; 8
     31e:	80 93 7c 01 	sts	0x017C, r24
	MelodyRegister &= ~EEPPLAYFLAG;   
     322:	80 91 7c 01 	lds	r24, 0x017C
     326:	8f 7e       	andi	r24, 0xEF	; 239
     328:	80 93 7c 01 	sts	0x017C, r24

    //메인 루틴에서 계속해서 돌도록         
    while(MelodyRegister & MelodyOnOffFLAG);     
     32c:	80 91 7c 01 	lds	r24, 0x017C
     330:	83 fd       	sbrc	r24, 3
     332:	fc cf       	rjmp	.-8      	; 0x32c <SetSpeaker+0x7e>
}
     334:	08 95       	ret

00000336 <DacDigToAlog>:

void DacDigToAlog(u08 pos, u08 DacDigData, u08 DacOpcode)
{
	u08 DigTemp;
	
	DigTemp = (u08)(DacOpcode | (DacDigData >>4));
     336:	96 2f       	mov	r25, r22
     338:	92 95       	swap	r25
     33a:	9f 70       	andi	r25, 0x0F	; 15
     33c:	49 2b       	or	r20, r25
	

	if(pos == 1){
     33e:	81 30       	cpi	r24, 0x01	; 1
     340:	f1 f4       	brne	.+60     	; 0x37e <DacDigToAlog+0x48>
		u08 i, j;
		
		//port setup
		sbi(DDRB,1);
     342:	b9 9a       	sbi	0x17, 1	; 23
				}else{
					cbi(PORTB, 1);		//Data input
					NOP();
				}
			}
			DigTemp = (u08)(DacDigData << 4 );
     344:	62 95       	swap	r22
     346:	60 7f       	andi	r22, 0xF0	; 240
     348:	72 e0       	ldi	r23, 0x02	; 2
     34a:	15 c0       	rjmp	.+42     	; 0x376 <DacDigToAlog+0x40>
		//port setup
		sbi(DDRB,1);
		
		for(j = 0; j < 2; j++){
			for(i=0;i<8;i++){
				if((DigTemp<<i) & 0x80){
     34c:	9a 01       	movw	r18, r20
     34e:	08 2e       	mov	r0, r24
     350:	02 c0       	rjmp	.+4      	; 0x356 <DacDigToAlog+0x20>
     352:	22 0f       	add	r18, r18
     354:	33 1f       	adc	r19, r19
     356:	0a 94       	dec	r0
     358:	e2 f7       	brpl	.-8      	; 0x352 <DacDigToAlog+0x1c>
     35a:	27 ff       	sbrs	r18, 7
     35c:	02 c0       	rjmp	.+4      	; 0x362 <DacDigToAlog+0x2c>
					sbi(PORTB,1);		//Data input
     35e:	c1 9a       	sbi	0x18, 1	; 24
     360:	01 c0       	rjmp	.+2      	; 0x364 <DacDigToAlog+0x2e>
					NOP();
				}else{
					cbi(PORTB, 1);		//Data input
     362:	c1 98       	cbi	0x18, 1	; 24
					NOP();
     364:	00 00       	nop
     366:	01 96       	adiw	r24, 0x01	; 1
		
		//port setup
		sbi(DDRB,1);
		
		for(j = 0; j < 2; j++){
			for(i=0;i<8;i++){
     368:	88 30       	cpi	r24, 0x08	; 8
     36a:	91 05       	cpc	r25, r1
     36c:	79 f7       	brne	.-34     	; 0x34c <DacDigToAlog+0x16>
     36e:	71 50       	subi	r23, 0x01	; 1
		u08 i, j;
		
		//port setup
		sbi(DDRB,1);
		
		for(j = 0; j < 2; j++){
     370:	09 f4       	brne	.+2      	; 0x374 <DacDigToAlog+0x3e>
     372:	8d c0       	rjmp	.+282    	; 0x48e <DacDigToAlog+0x158>
				}else{
					cbi(PORTB, 1);		//Data input
					NOP();
				}
			}
			DigTemp = (u08)(DacDigData << 4 );
     374:	46 2f       	mov	r20, r22
}



void DacDigToAlog(u08 pos, u08 DacDigData, u08 DacOpcode)
{
     376:	80 e0       	ldi	r24, 0x00	; 0
     378:	90 e0       	ldi	r25, 0x00	; 0
		//port setup
		sbi(DDRB,1);
		
		for(j = 0; j < 2; j++){
			for(i=0;i<8;i++){
				if((DigTemp<<i) & 0x80){
     37a:	50 e0       	ldi	r21, 0x00	; 0
     37c:	e7 cf       	rjmp	.-50     	; 0x34c <DacDigToAlog+0x16>
					NOP();
				}
			}
			DigTemp = (u08)(DacDigData << 4 );
		}	
	}else if(pos == 2){		//2번위치에 있을때
     37e:	82 30       	cpi	r24, 0x02	; 2
     380:	f1 f4       	brne	.+60     	; 0x3be <DacDigToAlog+0x88>
		u08 i2, j2;
				
		//port setup
		sbi(DDRD,1);
     382:	89 9a       	sbi	0x11, 1	; 17
				}else{
					cbi(PORTD, 1);		//Data input
					NOP();
				}				
			}
			DigTemp = (u08)(DacDigData << 4 );
     384:	62 95       	swap	r22
     386:	60 7f       	andi	r22, 0xF0	; 240
     388:	72 e0       	ldi	r23, 0x02	; 2
     38a:	15 c0       	rjmp	.+42     	; 0x3b6 <DacDigToAlog+0x80>
		//port setup
		sbi(DDRD,1);
		
		for(j2 = 0; j2 < 2; j2++){
			for(i2=0;i2<8;i2++){
				if((DigTemp<<i2) & 0x80){
     38c:	9a 01       	movw	r18, r20
     38e:	08 2e       	mov	r0, r24
     390:	02 c0       	rjmp	.+4      	; 0x396 <DacDigToAlog+0x60>
     392:	22 0f       	add	r18, r18
     394:	33 1f       	adc	r19, r19
     396:	0a 94       	dec	r0
     398:	e2 f7       	brpl	.-8      	; 0x392 <DacDigToAlog+0x5c>
     39a:	27 ff       	sbrs	r18, 7
     39c:	02 c0       	rjmp	.+4      	; 0x3a2 <DacDigToAlog+0x6c>
					sbi(PORTD,1);		//Data input				
     39e:	91 9a       	sbi	0x12, 1	; 18
     3a0:	01 c0       	rjmp	.+2      	; 0x3a4 <DacDigToAlog+0x6e>
					NOP();
				}else{
					cbi(PORTD, 1);		//Data input
     3a2:	91 98       	cbi	0x12, 1	; 18
					NOP();
     3a4:	00 00       	nop
     3a6:	01 96       	adiw	r24, 0x01	; 1
				
		//port setup
		sbi(DDRD,1);
		
		for(j2 = 0; j2 < 2; j2++){
			for(i2=0;i2<8;i2++){
     3a8:	88 30       	cpi	r24, 0x08	; 8
     3aa:	91 05       	cpc	r25, r1
     3ac:	79 f7       	brne	.-34     	; 0x38c <DacDigToAlog+0x56>
     3ae:	71 50       	subi	r23, 0x01	; 1
		u08 i2, j2;
				
		//port setup
		sbi(DDRD,1);
		
		for(j2 = 0; j2 < 2; j2++){
     3b0:	09 f4       	brne	.+2      	; 0x3b4 <DacDigToAlog+0x7e>
     3b2:	6d c0       	rjmp	.+218    	; 0x48e <DacDigToAlog+0x158>
				}else{
					cbi(PORTD, 1);		//Data input
					NOP();
				}				
			}
			DigTemp = (u08)(DacDigData << 4 );
     3b4:	46 2f       	mov	r20, r22
				}else{
					cbi(PORTB, 1);		//Data input
					NOP();
				}
			}
			DigTemp = (u08)(DacDigData << 4 );
     3b6:	80 e0       	ldi	r24, 0x00	; 0
     3b8:	90 e0       	ldi	r25, 0x00	; 0
		//port setup
		sbi(DDRD,1);
		
		for(j2 = 0; j2 < 2; j2++){
			for(i2=0;i2<8;i2++){
				if((DigTemp<<i2) & 0x80){
     3ba:	50 e0       	ldi	r21, 0x00	; 0
     3bc:	e7 cf       	rjmp	.-50     	; 0x38c <DacDigToAlog+0x56>
					NOP();
				}				
			}
			DigTemp = (u08)(DacDigData << 4 );
		}		
	}else if(pos == 3){		//3번위치에 있을때
     3be:	83 30       	cpi	r24, 0x03	; 3
     3c0:	f1 f4       	brne	.+60     	; 0x3fe <DacDigToAlog+0xc8>
		u08 i3, j3;
		
		//port setup
		sbi(DDRD,5);
     3c2:	8d 9a       	sbi	0x11, 5	; 17
				}else{
					cbi(PORTD, 5);		//Data input
					NOP();
				}				
			}
			DigTemp = (u08)(DacDigData << 4 );
     3c4:	62 95       	swap	r22
     3c6:	60 7f       	andi	r22, 0xF0	; 240
     3c8:	72 e0       	ldi	r23, 0x02	; 2
     3ca:	15 c0       	rjmp	.+42     	; 0x3f6 <DacDigToAlog+0xc0>
		//port setup
		sbi(DDRD,5);
				
		for(j3 = 0; j3 < 2; j3++){
			for(i3=0;i3<8;i3++){
				if((DigTemp<<i3) & 0x80){
     3cc:	9a 01       	movw	r18, r20
     3ce:	08 2e       	mov	r0, r24
     3d0:	02 c0       	rjmp	.+4      	; 0x3d6 <DacDigToAlog+0xa0>
     3d2:	22 0f       	add	r18, r18
     3d4:	33 1f       	adc	r19, r19
     3d6:	0a 94       	dec	r0
     3d8:	e2 f7       	brpl	.-8      	; 0x3d2 <DacDigToAlog+0x9c>
     3da:	27 ff       	sbrs	r18, 7
     3dc:	02 c0       	rjmp	.+4      	; 0x3e2 <DacDigToAlog+0xac>
					sbi(PORTD,5);		//Data input				
     3de:	95 9a       	sbi	0x12, 5	; 18
     3e0:	01 c0       	rjmp	.+2      	; 0x3e4 <DacDigToAlog+0xae>
					NOP();
				}else{
					cbi(PORTD, 5);		//Data input
     3e2:	95 98       	cbi	0x12, 5	; 18
					NOP();
     3e4:	00 00       	nop
     3e6:	01 96       	adiw	r24, 0x01	; 1
		
		//port setup
		sbi(DDRD,5);
				
		for(j3 = 0; j3 < 2; j3++){
			for(i3=0;i3<8;i3++){
     3e8:	88 30       	cpi	r24, 0x08	; 8
     3ea:	91 05       	cpc	r25, r1
     3ec:	79 f7       	brne	.-34     	; 0x3cc <DacDigToAlog+0x96>
     3ee:	71 50       	subi	r23, 0x01	; 1
		u08 i3, j3;
		
		//port setup
		sbi(DDRD,5);
				
		for(j3 = 0; j3 < 2; j3++){
     3f0:	09 f4       	brne	.+2      	; 0x3f4 <DacDigToAlog+0xbe>
     3f2:	4d c0       	rjmp	.+154    	; 0x48e <DacDigToAlog+0x158>
				}else{
					cbi(PORTD, 5);		//Data input
					NOP();
				}				
			}
			DigTemp = (u08)(DacDigData << 4 );
     3f4:	46 2f       	mov	r20, r22
				}else{
					cbi(PORTD, 1);		//Data input
					NOP();
				}				
			}
			DigTemp = (u08)(DacDigData << 4 );
     3f6:	80 e0       	ldi	r24, 0x00	; 0
     3f8:	90 e0       	ldi	r25, 0x00	; 0
		//port setup
		sbi(DDRD,5);
				
		for(j3 = 0; j3 < 2; j3++){
			for(i3=0;i3<8;i3++){
				if((DigTemp<<i3) & 0x80){
     3fa:	50 e0       	ldi	r21, 0x00	; 0
     3fc:	e7 cf       	rjmp	.-50     	; 0x3cc <DacDigToAlog+0x96>
				}				
			}
			DigTemp = (u08)(DacDigData << 4 );
		}		
	}	
	else if(pos == 4){		//2번위치에 있을때
     3fe:	84 30       	cpi	r24, 0x04	; 4
     400:	e9 f4       	brne	.+58     	; 0x43c <DacDigToAlog+0x106>
		u08 i4, j4;
				
		//port setup
		sbi(DDRE,1);
     402:	11 9a       	sbi	0x02, 1	; 2
				}else{
					cbi(PORTE, 1);		//Data input
					NOP();
				}				
			}
			DigTemp = (u08)(DacDigData << 4 );
     404:	62 95       	swap	r22
     406:	60 7f       	andi	r22, 0xF0	; 240
     408:	72 e0       	ldi	r23, 0x02	; 2
     40a:	14 c0       	rjmp	.+40     	; 0x434 <DacDigToAlog+0xfe>
		//port setup
		sbi(DDRE,1);
		
		for(j4 = 0; j4 < 2; j4++){
			for(i4=0;i4<8;i4++){
				if((DigTemp<<i4) & 0x80){
     40c:	9a 01       	movw	r18, r20
     40e:	08 2e       	mov	r0, r24
     410:	02 c0       	rjmp	.+4      	; 0x416 <DacDigToAlog+0xe0>
     412:	22 0f       	add	r18, r18
     414:	33 1f       	adc	r19, r19
     416:	0a 94       	dec	r0
     418:	e2 f7       	brpl	.-8      	; 0x412 <DacDigToAlog+0xdc>
     41a:	27 ff       	sbrs	r18, 7
     41c:	02 c0       	rjmp	.+4      	; 0x422 <DacDigToAlog+0xec>
					sbi(PORTE,1);		//Data input				
     41e:	19 9a       	sbi	0x03, 1	; 3
     420:	01 c0       	rjmp	.+2      	; 0x424 <DacDigToAlog+0xee>
					NOP();
				}else{
					cbi(PORTE, 1);		//Data input
     422:	19 98       	cbi	0x03, 1	; 3
					NOP();
     424:	00 00       	nop
     426:	01 96       	adiw	r24, 0x01	; 1
				
		//port setup
		sbi(DDRE,1);
		
		for(j4 = 0; j4 < 2; j4++){
			for(i4=0;i4<8;i4++){
     428:	88 30       	cpi	r24, 0x08	; 8
     42a:	91 05       	cpc	r25, r1
     42c:	79 f7       	brne	.-34     	; 0x40c <DacDigToAlog+0xd6>
     42e:	71 50       	subi	r23, 0x01	; 1
		u08 i4, j4;
				
		//port setup
		sbi(DDRE,1);
		
		for(j4 = 0; j4 < 2; j4++){
     430:	71 f1       	breq	.+92     	; 0x48e <DacDigToAlog+0x158>
				}else{
					cbi(PORTE, 1);		//Data input
					NOP();
				}				
			}
			DigTemp = (u08)(DacDigData << 4 );
     432:	46 2f       	mov	r20, r22
				}else{
					cbi(PORTD, 5);		//Data input
					NOP();
				}				
			}
			DigTemp = (u08)(DacDigData << 4 );
     434:	80 e0       	ldi	r24, 0x00	; 0
     436:	90 e0       	ldi	r25, 0x00	; 0
		//port setup
		sbi(DDRE,1);
		
		for(j4 = 0; j4 < 2; j4++){
			for(i4=0;i4<8;i4++){
				if((DigTemp<<i4) & 0x80){
     438:	50 e0       	ldi	r21, 0x00	; 0
     43a:	e8 cf       	rjmp	.-48     	; 0x40c <DacDigToAlog+0xd6>
				}				
			}
			DigTemp = (u08)(DacDigData << 4 );
		}		
	}	
	else if(pos == 5){		//2번위치에 있을때
     43c:	85 30       	cpi	r24, 0x05	; 5
     43e:	39 f5       	brne	.+78     	; 0x48e <DacDigToAlog+0x158>
		u08 i5, j5;
				
		//port setup
		sbi(DDRG,3);
     440:	80 91 64 00 	lds	r24, 0x0064
     444:	88 60       	ori	r24, 0x08	; 8
     446:	80 93 64 00 	sts	0x0064, r24
				}else{
					cbi(PORTG, 3);		//Data input
					NOP();
				}				
			}
			DigTemp = (u08)(DacDigData << 4 );
     44a:	62 95       	swap	r22
     44c:	60 7f       	andi	r22, 0xF0	; 240
     44e:	72 e0       	ldi	r23, 0x02	; 2
     450:	1a c0       	rjmp	.+52     	; 0x486 <DacDigToAlog+0x150>
		//port setup
		sbi(DDRG,3);
		
		for(j5 = 0; j5 < 2; j5++){
			for(i5=0;i5<8;i5++){
				if((DigTemp<<i5) & 0x80){
     452:	9a 01       	movw	r18, r20
     454:	08 2e       	mov	r0, r24
     456:	02 c0       	rjmp	.+4      	; 0x45c <DacDigToAlog+0x126>
     458:	22 0f       	add	r18, r18
     45a:	33 1f       	adc	r19, r19
     45c:	0a 94       	dec	r0
     45e:	e2 f7       	brpl	.-8      	; 0x458 <DacDigToAlog+0x122>
     460:	27 ff       	sbrs	r18, 7
     462:	04 c0       	rjmp	.+8      	; 0x46c <DacDigToAlog+0x136>
					sbi(PORTG,3);		//Data input				
     464:	20 91 65 00 	lds	r18, 0x0065
     468:	28 60       	ori	r18, 0x08	; 8
     46a:	03 c0       	rjmp	.+6      	; 0x472 <DacDigToAlog+0x13c>
					NOP();
				}else{
					cbi(PORTG, 3);		//Data input
     46c:	20 91 65 00 	lds	r18, 0x0065
     470:	27 7f       	andi	r18, 0xF7	; 247
     472:	20 93 65 00 	sts	0x0065, r18
					NOP();
     476:	00 00       	nop
     478:	01 96       	adiw	r24, 0x01	; 1
				
		//port setup
		sbi(DDRG,3);
		
		for(j5 = 0; j5 < 2; j5++){
			for(i5=0;i5<8;i5++){
     47a:	88 30       	cpi	r24, 0x08	; 8
     47c:	91 05       	cpc	r25, r1
     47e:	49 f7       	brne	.-46     	; 0x452 <DacDigToAlog+0x11c>
     480:	71 50       	subi	r23, 0x01	; 1
		u08 i5, j5;
				
		//port setup
		sbi(DDRG,3);
		
		for(j5 = 0; j5 < 2; j5++){
     482:	29 f0       	breq	.+10     	; 0x48e <DacDigToAlog+0x158>
				}else{
					cbi(PORTG, 3);		//Data input
					NOP();
				}				
			}
			DigTemp = (u08)(DacDigData << 4 );
     484:	46 2f       	mov	r20, r22
				}else{
					cbi(PORTE, 1);		//Data input
					NOP();
				}				
			}
			DigTemp = (u08)(DacDigData << 4 );
     486:	80 e0       	ldi	r24, 0x00	; 0
     488:	90 e0       	ldi	r25, 0x00	; 0
		//port setup
		sbi(DDRG,3);
		
		for(j5 = 0; j5 < 2; j5++){
			for(i5=0;i5<8;i5++){
				if((DigTemp<<i5) & 0x80){
     48a:	50 e0       	ldi	r21, 0x00	; 0
     48c:	e2 cf       	rjmp	.-60     	; 0x452 <DacDigToAlog+0x11c>
     48e:	08 95       	ret

00000490 <MelFunc>:
    //메인 루틴에서 계속해서 돌도록         
    while(MelodyRegister & MelodyOnOffFLAG);     
}

//---------------------------------------------------------
void MelFunc(void){						
     490:	cf 93       	push	r28
     492:	df 93       	push	r29
	static u08  l_mel_low  = 2;
	//u08 MelImpect = 0;

	//MelImpect = MelImpect>>4;
	
	if(MelImpect&0xf0){
     494:	80 91 46 01 	lds	r24, 0x0146
     498:	80 7f       	andi	r24, 0xF0	; 240
     49a:	69 f0       	breq	.+26     	; 0x4b6 <MelFunc+0x26>
		u08 shi_impect;
		shi_impect = MelImpect>>4;
     49c:	80 91 46 01 	lds	r24, 0x0146
     4a0:	82 95       	swap	r24
     4a2:	8f 70       	andi	r24, 0x0F	; 15
		l_mel_high = 115 + (shi_impect);
     4a4:	98 2f       	mov	r25, r24
     4a6:	9d 58       	subi	r25, 0x8D	; 141
     4a8:	90 93 3d 01 	sts	0x013D, r25
		l_mel_low  = 115 - (shi_impect);
     4ac:	93 e7       	ldi	r25, 0x73	; 115
     4ae:	98 1b       	sub	r25, r24
     4b0:	90 93 3c 01 	sts	0x013C, r25
     4b4:	06 c0       	rjmp	.+12     	; 0x4c2 <MelFunc+0x32>
	} else {
		l_mel_high = M_DAC_H;
     4b6:	8d e7       	ldi	r24, 0x7D	; 125
     4b8:	80 93 3d 01 	sts	0x013D, r24
		l_mel_low  = M_DAC_L;
     4bc:	89 e6       	ldi	r24, 0x69	; 105
     4be:	80 93 3c 01 	sts	0x013C, r24
	}
	
	l_mel_high += (MelVolCtrl );
     4c2:	90 91 12 01 	lds	r25, 0x0112
     4c6:	80 91 3d 01 	lds	r24, 0x013D
     4ca:	98 0f       	add	r25, r24
     4cc:	90 93 3d 01 	sts	0x013D, r25
	l_mel_low  -= (MelVolCtrl );
     4d0:	80 91 12 01 	lds	r24, 0x0112
     4d4:	60 91 3c 01 	lds	r22, 0x013C
     4d8:	68 1b       	sub	r22, r24
     4da:	60 93 3c 01 	sts	0x013C, r22

	if(MelodyRegister&MelodyOnOffFLAG){
     4de:	80 91 7c 01 	lds	r24, 0x017C
     4e2:	83 ff       	sbrs	r24, 3
     4e4:	75 c1       	rjmp	.+746    	; 0x7d0 <MelFunc+0x340>
	
	 	if(( -- Kong_ovf_count)==0)	KongCount -= 1;  
     4e6:	80 91 e7 01 	lds	r24, 0x01E7
     4ea:	81 50       	subi	r24, 0x01	; 1
     4ec:	80 93 e7 01 	sts	0x01E7, r24
     4f0:	88 23       	and	r24, r24
     4f2:	29 f4       	brne	.+10     	; 0x4fe <MelFunc+0x6e>
     4f4:	80 91 ee 01 	lds	r24, 0x01EE
     4f8:	81 50       	subi	r24, 0x01	; 1
     4fa:	80 93 ee 01 	sts	0x01EE, r24
		
		if(MelodyRegister & EEPPLAYFLAG){
     4fe:	80 91 7c 01 	lds	r24, 0x017C
     502:	84 ff       	sbrs	r24, 4
     504:	a7 c0       	rjmp	.+334    	; 0x654 <MelFunc+0x1c4>
			
			if(MelodyRegister & InvertFLAG){ 
     506:	80 91 7c 01 	lds	r24, 0x017C
     50a:	80 ff       	sbrs	r24, 0
     50c:	52 c1       	rjmp	.+676    	; 0x7b2 <MelFunc+0x322>
		
				if(!(MelodyRegister & BREAKTIME)){	
     50e:	80 91 7c 01 	lds	r24, 0x017C
     512:	82 fd       	sbrc	r24, 2
     514:	18 c0       	rjmp	.+48     	; 0x546 <MelFunc+0xb6>
		      		if(MelodyRegister& SpFLAG){		// 스피커 포트 인버트		      			
     516:	80 91 7c 01 	lds	r24, 0x017C
     51a:	81 ff       	sbrs	r24, 1
     51c:	09 c0       	rjmp	.+18     	; 0x530 <MelFunc+0xa0>
						DAC_OUTDATA(m_nPos_Speaker,l_mel_low);
     51e:	80 91 57 01 	lds	r24, 0x0157
     522:	40 e0       	ldi	r20, 0x00	; 0
     524:	0e 94 9b 01 	call	0x336	; 0x336 <DacDigToAlog>
						MelodyRegister &= ~SpFLAG;
     528:	80 91 7c 01 	lds	r24, 0x017C
     52c:	8d 7f       	andi	r24, 0xFD	; 253
     52e:	09 c0       	rjmp	.+18     	; 0x542 <MelFunc+0xb2>
					} else {						
						DAC_OUTDATA(m_nPos_Speaker,l_mel_high);						
     530:	80 91 57 01 	lds	r24, 0x0157
     534:	69 2f       	mov	r22, r25
     536:	40 e0       	ldi	r20, 0x00	; 0
     538:	0e 94 9b 01 	call	0x336	; 0x336 <DacDigToAlog>
						MelodyRegister |=SpFLAG;
     53c:	80 91 7c 01 	lds	r24, 0x017C
     540:	82 60       	ori	r24, 0x02	; 2
     542:	80 93 7c 01 	sts	0x017C, r24
					}
				}
				
				if(KongCount==0){ 	//다음 멜로디 호출					
     546:	80 91 ee 01 	lds	r24, 0x01EE
     54a:	88 23       	and	r24, r24
     54c:	09 f0       	breq	.+2      	; 0x550 <MelFunc+0xc0>
     54e:	7c c0       	rjmp	.+248    	; 0x648 <MelFunc+0x1b8>
			     	MelodyRegister &= ~BREAKTIME;
     550:	80 91 7c 01 	lds	r24, 0x017C
     554:	8b 7f       	andi	r24, 0xFB	; 251
     556:	80 93 7c 01 	sts	0x017C, r24
			
					if(!(EepMelAddr>60)){
     55a:	80 91 5b 01 	lds	r24, 0x015B
     55e:	8d 33       	cpi	r24, 0x3D	; 61
     560:	98 f5       	brcc	.+102    	; 0x5c8 <MelFunc+0x138>
						pM_++;		pK_++;
     562:	c0 91 c1 01 	lds	r28, 0x01C1
     566:	d0 91 c2 01 	lds	r29, 0x01C2
     56a:	ce 01       	movw	r24, r28
     56c:	01 96       	adiw	r24, 0x01	; 1
     56e:	90 93 c2 01 	sts	0x01C2, r25
     572:	80 93 c1 01 	sts	0x01C1, r24
     576:	a0 91 e8 01 	lds	r26, 0x01E8
     57a:	b0 91 e9 01 	lds	r27, 0x01E9
     57e:	cd 01       	movw	r24, r26
     580:	01 96       	adiw	r24, 0x01	; 1
     582:	90 93 e9 01 	sts	0x01E9, r25
     586:	80 93 e8 01 	sts	0x01E8, r24
						OvfCount 	= pgm_read_byte(&Melody_Tof_count[*pM_]);
     58a:	e9 81       	ldd	r30, Y+1	; 0x01
     58c:	f0 e0       	ldi	r31, 0x00	; 0
     58e:	e4 57       	subi	r30, 0x74	; 116
     590:	ff 4f       	sbci	r31, 0xFF	; 255
     592:	e4 91       	lpm	r30, Z+
     594:	e0 93 bc 01 	sts	0x01BC, r30
						SubTimeValue= pgm_read_byte(&Melody_Sub_Time[ *pM_]);	
     598:	e9 81       	ldd	r30, Y+1	; 0x01
     59a:	f0 e0       	ldi	r31, 0x00	; 0
     59c:	e2 55       	subi	r30, 0x52	; 82
     59e:	ff 4f       	sbci	r31, 0xFF	; 255
     5a0:	e4 91       	lpm	r30, Z+
     5a2:	e0 93 81 01 	sts	0x0181, r30
						MelImpect = *pK_;		
     5a6:	11 96       	adiw	r26, 0x01	; 1
     5a8:	8c 91       	ld	r24, X
     5aa:	11 97       	sbiw	r26, 0x01	; 1
     5ac:	80 93 46 01 	sts	0x0146, r24
						KongCount 	= pgm_read_byte(&Melody_Kongnamul[0x0f&(*pK_)]);	
     5b0:	11 96       	adiw	r26, 0x01	; 1
     5b2:	ec 91       	ld	r30, X
     5b4:	11 97       	sbiw	r26, 0x01	; 1
     5b6:	f0 e0       	ldi	r31, 0x00	; 0
     5b8:	ef 70       	andi	r30, 0x0F	; 15
     5ba:	f0 70       	andi	r31, 0x00	; 0
     5bc:	e0 53       	subi	r30, 0x30	; 48
     5be:	ff 4f       	sbci	r31, 0xFF	; 255
     5c0:	e4 91       	lpm	r30, Z+
     5c2:	e0 93 ee 01 	sts	0x01EE, r30
     5c6:	05 c0       	rjmp	.+10     	; 0x5d2 <MelFunc+0x142>
					} else {
						MelodyRegister &= ~EEPPLAYFLAG;
     5c8:	80 91 7c 01 	lds	r24, 0x017C
     5cc:	8f 7e       	andi	r24, 0xEF	; 239
     5ce:	80 93 7c 01 	sts	0x017C, r24
					}
		            
		            
		  		    if(OvfCount== ENDCODE){
     5d2:	80 91 bc 01 	lds	r24, 0x01BC
     5d6:	80 38       	cpi	r24, 0x80	; 128
     5d8:	a1 f4       	brne	.+40     	; 0x602 <MelFunc+0x172>
		  		       
		  		    	MelodyRegister &= ~EEPPLAYFLAG;
     5da:	80 91 7c 01 	lds	r24, 0x017C
     5de:	8f 7e       	andi	r24, 0xEF	; 239
     5e0:	80 93 7c 01 	sts	0x017C, r24
		  				ENDMELODY();
     5e4:	80 91 7c 01 	lds	r24, 0x017C
     5e8:	87 7f       	andi	r24, 0xF7	; 247
     5ea:	80 93 7c 01 	sts	0x017C, r24
						
	  				
						DAC_OUTDATA(m_nPos_Speaker,M_DAC_M);
     5ee:	80 91 57 01 	lds	r24, 0x0157
     5f2:	63 e7       	ldi	r22, 0x73	; 115
     5f4:	40 e0       	ldi	r20, 0x00	; 0
     5f6:	0e 94 9b 01 	call	0x336	; 0x336 <DacDigToAlog>
	
    	                m_bMelodyEnd = 1;   //멜로디 끝났다.   
     5fa:	81 e0       	ldi	r24, 0x01	; 1
     5fc:	80 93 59 01 	sts	0x0159, r24
     600:	d3 c0       	rjmp	.+422    	; 0x7a8 <MelFunc+0x318>
	  				
		 			}else if(OvfCount== REPLAYCODE){
     602:	80 34       	cpi	r24, 0x40	; 64
     604:	09 f4       	brne	.+2      	; 0x608 <MelFunc+0x178>
     606:	d0 c0       	rjmp	.+416    	; 0x7a8 <MelFunc+0x318>
						//EepMelGnrate();
						
					} else if(OvfCount== REPLAYNUMBERCODE){
     608:	80 32       	cpi	r24, 0x20	; 32
     60a:	d1 f4       	brne	.+52     	; 0x640 <MelFunc+0x1b0>
						
						static u08 replycnt=0;
		
						if(MelodyRegister&EEPREPLAYNUMBERFLAG){
     60c:	80 91 7c 01 	lds	r24, 0x017C
     610:	85 ff       	sbrs	r24, 5
     612:	0d c0       	rjmp	.+26     	; 0x62e <MelFunc+0x19e>
							replycnt = *pK_;
     614:	e0 91 e8 01 	lds	r30, 0x01E8
     618:	f0 91 e9 01 	lds	r31, 0x01E9
							replycnt &= 0x0f;
     61c:	80 81       	ld	r24, Z
     61e:	8f 70       	andi	r24, 0x0F	; 15
     620:	80 93 4e 01 	sts	0x014E, r24
							MelodyRegister&= ~EEPREPLAYNUMBERFLAG;					
     624:	80 91 7c 01 	lds	r24, 0x017C
     628:	8f 7d       	andi	r24, 0xDF	; 223
     62a:	80 93 7c 01 	sts	0x017C, r24
						}
						if(!(replycnt == 0)){
     62e:	80 91 4e 01 	lds	r24, 0x014E
     632:	88 23       	and	r24, r24
     634:	09 f4       	brne	.+2      	; 0x638 <MelFunc+0x1a8>
     636:	6d c0       	rjmp	.+218    	; 0x712 <MelFunc+0x282>
							replycnt--;
     638:	81 50       	subi	r24, 0x01	; 1
     63a:	80 93 4e 01 	sts	0x014E, r24
     63e:	b4 c0       	rjmp	.+360    	; 0x7a8 <MelFunc+0x318>
							
	
							DAC_OUTDATA(m_nPos_Speaker,M_DAC_M);
							
						}
		  			} else if(OvfCount == 0xc0)	MelodyRegister |= BREAKTIME;
     640:	80 3c       	cpi	r24, 0xC0	; 192
     642:	09 f0       	breq	.+2      	; 0x646 <MelFunc+0x1b6>
     644:	b1 c0       	rjmp	.+354    	; 0x7a8 <MelFunc+0x318>
     646:	a3 c0       	rjmp	.+326    	; 0x78e <MelFunc+0x2fe>
				} else {			// 이전 음(주파수) 생성
					OvfCount 	= pgm_read_byte(&Melody_Tof_count[*pM_]);
     648:	e0 91 c1 01 	lds	r30, 0x01C1
     64c:	f0 91 c2 01 	lds	r31, 0x01C2
     650:	e0 81       	ld	r30, Z
     652:	a4 c0       	rjmp	.+328    	; 0x79c <MelFunc+0x30c>
				MelodyRegister &= ~ InvertFLAG;	
			}			
			
		}
		else {		
			if(MelodyRegister & InvertFLAG){ 		
     654:	80 91 7c 01 	lds	r24, 0x017C
     658:	80 ff       	sbrs	r24, 0
     65a:	ab c0       	rjmp	.+342    	; 0x7b2 <MelFunc+0x322>
				if(!(MelodyRegister & BREAKTIME)){	
     65c:	80 91 7c 01 	lds	r24, 0x017C
     660:	82 fd       	sbrc	r24, 2
     662:	18 c0       	rjmp	.+48     	; 0x694 <MelFunc+0x204>
		      		if(MelodyRegister& SpFLAG){		// 스피커 포트 인버트
     664:	80 91 7c 01 	lds	r24, 0x017C
     668:	81 ff       	sbrs	r24, 1
     66a:	09 c0       	rjmp	.+18     	; 0x67e <MelFunc+0x1ee>
						DAC_OUTDATA(m_nPos_Speaker,l_mel_low);
     66c:	80 91 57 01 	lds	r24, 0x0157
     670:	40 e0       	ldi	r20, 0x00	; 0
     672:	0e 94 9b 01 	call	0x336	; 0x336 <DacDigToAlog>
						MelodyRegister &= ~SpFLAG;
     676:	80 91 7c 01 	lds	r24, 0x017C
     67a:	8d 7f       	andi	r24, 0xFD	; 253
     67c:	09 c0       	rjmp	.+18     	; 0x690 <MelFunc+0x200>
					} else {
						DAC_OUTDATA(m_nPos_Speaker,l_mel_high);
     67e:	80 91 57 01 	lds	r24, 0x0157
     682:	69 2f       	mov	r22, r25
     684:	40 e0       	ldi	r20, 0x00	; 0
     686:	0e 94 9b 01 	call	0x336	; 0x336 <DacDigToAlog>
						MelodyRegister |=SpFLAG;
     68a:	80 91 7c 01 	lds	r24, 0x017C
     68e:	82 60       	ori	r24, 0x02	; 2
     690:	80 93 7c 01 	sts	0x017C, r24
					}
				}
				if(KongCount==0){ 	//다음 멜로디 호출
     694:	80 91 ee 01 	lds	r24, 0x01EE
     698:	e0 91 c1 01 	lds	r30, 0x01C1
     69c:	f0 91 c2 01 	lds	r31, 0x01C2
     6a0:	88 23       	and	r24, r24
     6a2:	09 f0       	breq	.+2      	; 0x6a6 <MelFunc+0x216>
     6a4:	7a c0       	rjmp	.+244    	; 0x79a <MelFunc+0x30a>
			     	pM_++;	pK_++;	MelodyRegister &= ~BREAKTIME;
     6a6:	31 96       	adiw	r30, 0x01	; 1
     6a8:	f0 93 c2 01 	sts	0x01C2, r31
     6ac:	e0 93 c1 01 	sts	0x01C1, r30
     6b0:	80 91 e8 01 	lds	r24, 0x01E8
     6b4:	90 91 e9 01 	lds	r25, 0x01E9
     6b8:	01 96       	adiw	r24, 0x01	; 1
     6ba:	90 93 e9 01 	sts	0x01E9, r25
     6be:	80 93 e8 01 	sts	0x01E8, r24
     6c2:	20 91 7c 01 	lds	r18, 0x017C
     6c6:	2b 7f       	andi	r18, 0xFB	; 251
     6c8:	20 93 7c 01 	sts	0x017C, r18
		
					OvfCount 	= pgm_read_byte(&Melody_Tof_count[pgm_read_byte(pM_)]);
     6cc:	e4 91       	lpm	r30, Z+
     6ce:	2e 2f       	mov	r18, r30
     6d0:	30 e0       	ldi	r19, 0x00	; 0
     6d2:	f9 01       	movw	r30, r18
     6d4:	e4 57       	subi	r30, 0x74	; 116
     6d6:	ff 4f       	sbci	r31, 0xFF	; 255
     6d8:	44 91       	lpm	r20, Z+
     6da:	40 93 bc 01 	sts	0x01BC, r20
					SubTimeValue= pgm_read_byte(&Melody_Sub_Time[pgm_read_byte(pM_)]);
     6de:	22 55       	subi	r18, 0x52	; 82
     6e0:	3f 4f       	sbci	r19, 0xFF	; 255
     6e2:	f9 01       	movw	r30, r18
     6e4:	24 91       	lpm	r18, Z+
     6e6:	20 93 81 01 	sts	0x0181, r18
					MelImpect = pgm_read_byte(pK_);
     6ea:	fc 01       	movw	r30, r24
     6ec:	84 91       	lpm	r24, Z+
     6ee:	80 93 46 01 	sts	0x0146, r24
					KongCount 	= pgm_read_byte(&Melody_Kongnamul[(0x0f &(pgm_read_byte(pK_)))]);
     6f2:	e8 2f       	mov	r30, r24
     6f4:	f0 e0       	ldi	r31, 0x00	; 0
     6f6:	ef 70       	andi	r30, 0x0F	; 15
     6f8:	f0 70       	andi	r31, 0x00	; 0
     6fa:	e0 53       	subi	r30, 0x30	; 48
     6fc:	ff 4f       	sbci	r31, 0xFF	; 255
     6fe:	e4 91       	lpm	r30, Z+
     700:	e0 93 ee 01 	sts	0x01EE, r30
		
		  		    if(OvfCount== ENDCODE){
     704:	40 38       	cpi	r20, 0x80	; 128
     706:	89 f4       	brne	.+34     	; 0x72a <MelFunc+0x29a>
		  		    	MelodyRegister &= ~EEPPLAYFLAG;
     708:	80 91 7c 01 	lds	r24, 0x017C
     70c:	8f 7e       	andi	r24, 0xEF	; 239
     70e:	80 93 7c 01 	sts	0x017C, r24
		  				ENDMELODY();
     712:	80 91 7c 01 	lds	r24, 0x017C
     716:	87 7f       	andi	r24, 0xF7	; 247
     718:	80 93 7c 01 	sts	0x017C, r24
						
						DAC_OUTDATA(m_nPos_Speaker,M_DAC_M);						
     71c:	80 91 57 01 	lds	r24, 0x0157
     720:	63 e7       	ldi	r22, 0x73	; 115
     722:	40 e0       	ldi	r20, 0x00	; 0
     724:	0e 94 9b 01 	call	0x336	; 0x336 <DacDigToAlog>
     728:	3f c0       	rjmp	.+126    	; 0x7a8 <MelFunc+0x318>
		 			} else if(OvfCount== REPLAYCODE){
     72a:	40 34       	cpi	r20, 0x40	; 64
     72c:	71 f5       	brne	.+92     	; 0x78a <MelFunc+0x2fa>
						pM_ = pM_refrash;	pK_ = pK_refrash;
     72e:	90 91 6f 01 	lds	r25, 0x016F
     732:	80 91 70 01 	lds	r24, 0x0170
     736:	90 93 c1 01 	sts	0x01C1, r25
     73a:	80 93 c2 01 	sts	0x01C2, r24
     73e:	30 91 71 01 	lds	r19, 0x0171
     742:	20 91 72 01 	lds	r18, 0x0172
     746:	30 93 e8 01 	sts	0x01E8, r19
     74a:	20 93 e9 01 	sts	0x01E9, r18
						OvfCount 	= pgm_read_byte(&Melody_Tof_count[pgm_read_byte(pM_)]);
     74e:	e9 2f       	mov	r30, r25
     750:	f8 2f       	mov	r31, r24
     752:	84 91       	lpm	r24, Z+
     754:	90 e0       	ldi	r25, 0x00	; 0
     756:	fc 01       	movw	r30, r24
     758:	e4 57       	subi	r30, 0x74	; 116
     75a:	ff 4f       	sbci	r31, 0xFF	; 255
     75c:	e4 91       	lpm	r30, Z+
     75e:	e0 93 bc 01 	sts	0x01BC, r30
						SubTimeValue= pgm_read_byte(&Melody_Sub_Time[pgm_read_byte(pM_)]);
     762:	82 55       	subi	r24, 0x52	; 82
     764:	9f 4f       	sbci	r25, 0xFF	; 255
     766:	fc 01       	movw	r30, r24
     768:	84 91       	lpm	r24, Z+
     76a:	80 93 81 01 	sts	0x0181, r24
						MelImpect = pgm_read_byte(pK_);
     76e:	e3 2f       	mov	r30, r19
     770:	f2 2f       	mov	r31, r18
     772:	e4 91       	lpm	r30, Z+
     774:	e0 93 46 01 	sts	0x0146, r30
						KongCount 	= pgm_read_byte(&Melody_Kongnamul[(0x0f&(pgm_read_byte(pK_)))]); 
     778:	f0 e0       	ldi	r31, 0x00	; 0
     77a:	ef 70       	andi	r30, 0x0F	; 15
     77c:	f0 70       	andi	r31, 0x00	; 0
     77e:	e0 53       	subi	r30, 0x30	; 48
     780:	ff 4f       	sbci	r31, 0xFF	; 255
     782:	e4 91       	lpm	r30, Z+
     784:	e0 93 ee 01 	sts	0x01EE, r30
     788:	0f c0       	rjmp	.+30     	; 0x7a8 <MelFunc+0x318>
		  			} else if(OvfCount == 0xc0)	MelodyRegister |= BREAKTIME;
     78a:	40 3c       	cpi	r20, 0xC0	; 192
     78c:	69 f4       	brne	.+26     	; 0x7a8 <MelFunc+0x318>
     78e:	80 91 7c 01 	lds	r24, 0x017C
     792:	84 60       	ori	r24, 0x04	; 4
     794:	80 93 7c 01 	sts	0x017C, r24
     798:	07 c0       	rjmp	.+14     	; 0x7a8 <MelFunc+0x318>
		  			
				} else {			// 이전 음(주파수) 생성
					OvfCount 	= pgm_read_byte(&Melody_Tof_count[pgm_read_byte(pM_)]);
     79a:	e4 91       	lpm	r30, Z+
     79c:	f0 e0       	ldi	r31, 0x00	; 0
     79e:	e4 57       	subi	r30, 0x74	; 116
     7a0:	ff 4f       	sbci	r31, 0xFF	; 255
     7a2:	e4 91       	lpm	r30, Z+
     7a4:	e0 93 bc 01 	sts	0x01BC, r30
				}				
				MelodyRegister &= ~ InvertFLAG;	
     7a8:	80 91 7c 01 	lds	r24, 0x017C
     7ac:	8e 7f       	andi	r24, 0xFE	; 254
     7ae:	80 93 7c 01 	sts	0x017C, r24
			}	    		
		}  
		
		    
		if((--OvfCount)==1){ 				//overflow 횟수가 맞으면 시간 조정
     7b2:	80 91 bc 01 	lds	r24, 0x01BC
     7b6:	81 50       	subi	r24, 0x01	; 1
     7b8:	80 93 bc 01 	sts	0x01BC, r24
     7bc:	81 30       	cpi	r24, 0x01	; 1
     7be:	41 f4       	brne	.+16     	; 0x7d0 <MelFunc+0x340>
			MelodyRegister |= InvertFLAG;
     7c0:	80 91 7c 01 	lds	r24, 0x017C
     7c4:	81 60       	ori	r24, 0x01	; 1
     7c6:	80 93 7c 01 	sts	0x017C, r24
			outp(SubTimeValue,TCNT0);
     7ca:	80 91 81 01 	lds	r24, 0x0181
     7ce:	82 bf       	out	0x32, r24	; 50
		}    
		
	}	
}
     7d0:	df 91       	pop	r29
     7d2:	cf 91       	pop	r28
     7d4:	08 95       	ret

000007d6 <GetRemocon>:

//////////////////////////////////////////////////////
//리모콘 함수들

u08 GetRemocon()
{
     7d6:	1f 93       	push	r17
     7d8:	df 93       	push	r29
     7da:	cf 93       	push	r28
     7dc:	00 d0       	rcall	.+0      	; 0x7de <GetRemocon+0x8>
     7de:	00 d0       	rcall	.+0      	; 0x7e0 <GetRemocon+0xa>
     7e0:	00 d0       	rcall	.+0      	; 0x7e2 <GetRemocon+0xc>
     7e2:	cd b7       	in	r28, 0x3d	; 61
     7e4:	de b7       	in	r29, 0x3e	; 62
	
	u08 temp[6],i,ird1,ird2,ir_1;
	u08* pData;
    
	ir_1 = ir_data[0];
     7e6:	10 91 5c 01 	lds	r17, 0x015C
	temp[0] = ~ir_data[1];	
     7ea:	80 91 5d 01 	lds	r24, 0x015D
     7ee:	80 95       	com	r24
     7f0:	89 83       	std	Y+1, r24	; 0x01
	ird1 = ir_data[2];	//데이타값 리턴		
     7f2:	80 91 5e 01 	lds	r24, 0x015E
	ird2 = ir_data[3];	
     7f6:	90 91 5f 01 	lds	r25, 0x015F
     7fa:	fe 01       	movw	r30, r28
     7fc:	32 96       	adiw	r30, 0x02	; 2
     7fe:	27 e0       	ldi	r18, 0x07	; 7
     800:	30 e0       	ldi	r19, 0x00	; 0


//////////////////////////////////////////////////////
//리모콘 함수들

u08 GetRemocon()
     802:	a8 e0       	ldi	r26, 0x08	; 8
     804:	b0 e0       	ldi	r27, 0x00	; 0
	ird1 = ir_data[2];	//데이타값 리턴		
	ird2 = ir_data[3];	
	
	for(i=1;i<6; i++)
	{			
		temp[i]  = temp[0]>>i;		
     806:	49 81       	ldd	r20, Y+1	; 0x01
     808:	50 e0       	ldi	r21, 0x00	; 0


//////////////////////////////////////////////////////
//리모콘 함수들

u08 GetRemocon()
     80a:	bd 01       	movw	r22, r26
     80c:	62 1b       	sub	r22, r18
     80e:	73 0b       	sbc	r23, r19
	ird1 = ir_data[2];	//데이타값 리턴		
	ird2 = ir_data[3];	
	
	for(i=1;i<6; i++)
	{			
		temp[i]  = temp[0]>>i;		
     810:	02 c0       	rjmp	.+4      	; 0x816 <GetRemocon+0x40>
     812:	55 95       	asr	r21
     814:	47 95       	ror	r20
     816:	6a 95       	dec	r22
     818:	e2 f7       	brpl	.-8      	; 0x812 <GetRemocon+0x3c>
     81a:	40 83       	st	Z, r20
		temp[i] |= temp[0]<<(8-i);	
     81c:	69 81       	ldd	r22, Y+1	; 0x01
     81e:	70 e0       	ldi	r23, 0x00	; 0
     820:	02 2e       	mov	r0, r18
     822:	02 c0       	rjmp	.+4      	; 0x828 <GetRemocon+0x52>
     824:	66 0f       	add	r22, r22
     826:	77 1f       	adc	r23, r23
     828:	0a 94       	dec	r0
     82a:	e2 f7       	brpl	.-8      	; 0x824 <GetRemocon+0x4e>
     82c:	46 2b       	or	r20, r22
     82e:	41 93       	st	Z+, r20
     830:	21 50       	subi	r18, 0x01	; 1
     832:	30 40       	sbci	r19, 0x00	; 0
	ir_1 = ir_data[0];
	temp[0] = ~ir_data[1];	
	ird1 = ir_data[2];	//데이타값 리턴		
	ird2 = ir_data[3];	
	
	for(i=1;i<6; i++)
     834:	22 30       	cpi	r18, 0x02	; 2
     836:	31 05       	cpc	r19, r1
     838:	31 f7       	brne	.-52     	; 0x806 <GetRemocon+0x30>
	{			
		temp[i]  = temp[0]>>i;		
		temp[i] |= temp[0]<<(8-i);	
	}
   	if(ir_1 == temp[1])
     83a:	2a 81       	ldd	r18, Y+2	; 0x02
     83c:	12 17       	cp	r17, r18
     83e:	11 f4       	brne	.+4      	; 0x844 <GetRemocon+0x6e>
	{	            // 	C ^C<<1 D ^D
	
		temp[1] = ~ird2;			//
     840:	90 95       	com	r25
		if(ird1 == temp[1]){
     842:	89 13       	cpse	r24, r25
       		pData = &ird1;
			return *pData;
		}
	} 	
	
	return 0;
     844:	80 e0       	ldi	r24, 0x00	; 0
}
     846:	26 96       	adiw	r28, 0x06	; 6
     848:	0f b6       	in	r0, 0x3f	; 63
     84a:	f8 94       	cli
     84c:	de bf       	out	0x3e, r29	; 62
     84e:	0f be       	out	0x3f, r0	; 63
     850:	cd bf       	out	0x3d, r28	; 61
     852:	cf 91       	pop	r28
     854:	df 91       	pop	r29
     856:	1f 91       	pop	r17
     858:	08 95       	ret

0000085a <IrRecv>:
{

	static u08	c_count = 0, s_count = 0;

// DETECT SET	
	if((1<<IR_RX_PIN)&inp(IRRxPORT)){		
     85a:	80 b1       	in	r24, 0x00	; 0
     85c:	90 e0       	ldi	r25, 0x00	; 0
     85e:	00 90 75 01 	lds	r0, 0x0175
     862:	02 c0       	rjmp	.+4      	; 0x868 <IrRecv+0xe>
     864:	95 95       	asr	r25
     866:	87 95       	ror	r24
     868:	0a 94       	dec	r0
     86a:	e2 f7       	brpl	.-8      	; 0x864 <IrRecv+0xa>
     86c:	80 ff       	sbrs	r24, 0
     86e:	35 c0       	rjmp	.+106    	; 0x8da <IrRecv+0x80>

			//이전 상태가 low 면	// set_FLAG   <===SET	// clear_FLAG <=== CLEAR
		if(IRReg & clear_d_FLAG){	IRReg |= set_d_FLAG;	IRReg &= ~clear_d_FLAG;	
     870:	80 91 0d 01 	lds	r24, 0x010D
     874:	85 ff       	sbrs	r24, 5
     876:	27 c0       	rjmp	.+78     	; 0x8c6 <IrRecv+0x6c>
     878:	80 91 0d 01 	lds	r24, 0x010D
     87c:	80 61       	ori	r24, 0x10	; 16
     87e:	80 93 0d 01 	sts	0x010D, r24
     882:	80 91 0d 01 	lds	r24, 0x010D
     886:	8f 7d       	andi	r24, 0xDF	; 223
     888:	80 93 0d 01 	sts	0x010D, r24

			if((2< c_count)&&(c_count <12 )){	T_count += 1;		//T
     88c:	80 91 4d 01 	lds	r24, 0x014D
     890:	98 2f       	mov	r25, r24
     892:	93 50       	subi	r25, 0x03	; 3
     894:	99 30       	cpi	r25, 0x09	; 9
     896:	30 f4       	brcc	.+12     	; 0x8a4 <IrRecv+0x4a>
     898:	80 91 7b 01 	lds	r24, 0x017B
     89c:	8f 5f       	subi	r24, 0xFF	; 255
     89e:	80 93 7b 01 	sts	0x017B, r24
     8a2:	0f c0       	rjmp	.+30     	; 0x8c2 <IrRecv+0x68>
			
			} else if(c_count >29){									//4T +
     8a4:	8e 31       	cpi	r24, 0x1E	; 30
     8a6:	68 f0       	brcs	.+26     	; 0x8c2 <IrRecv+0x68>
				
				
				//NONFLASHSENSBF=1;	
				
				cbi(PORTC, SENS_TRIG);	
     8a8:	ae 98       	cbi	0x15, 6	; 21

				u08 kk;
				for(kk =0;kk<4;kk++)ir_data[kk] =0;//ir_data
     8aa:	10 92 5c 01 	sts	0x015C, r1
     8ae:	10 92 5d 01 	sts	0x015D, r1
     8b2:	10 92 5e 01 	sts	0x015E, r1
     8b6:	10 92 5f 01 	sts	0x015F, r1
				OnlyIrCnt = 0;	T_count=0;
     8ba:	10 92 44 01 	sts	0x0144, r1
     8be:	10 92 7b 01 	sts	0x017B, r1
			}
			s_count = 0;
     8c2:	10 92 4c 01 	sts	0x014C, r1
		}

		if(s_count >250);	else  s_count++;	// over flow 방지 
     8c6:	80 91 4c 01 	lds	r24, 0x014C
     8ca:	8b 3f       	cpi	r24, 0xFB	; 251
     8cc:	18 f4       	brcc	.+6      	; 0x8d4 <IrRecv+0x7a>
     8ce:	8f 5f       	subi	r24, 0xFF	; 255
     8d0:	80 93 4c 01 	sts	0x014C, r24

		c_count = 0;	
     8d4:	10 92 4d 01 	sts	0x014D, r1
     8d8:	9e c0       	rjmp	.+316    	; 0xa16 <IrRecv+0x1bc>
			
// DETECT LOW		
	} else {		
			//이전 상태가 high면	// clear_FLAG <===SET	// set_FLAG   <=== CLEAR
		if(IRReg & set_d_FLAG){	
     8da:	80 91 0d 01 	lds	r24, 0x010D
     8de:	84 ff       	sbrs	r24, 4
     8e0:	91 c0       	rjmp	.+290    	; 0xa04 <IrRecv+0x1aa>
			IRReg |= clear_d_FLAG;
     8e2:	80 91 0d 01 	lds	r24, 0x010D
     8e6:	80 62       	ori	r24, 0x20	; 32
     8e8:	80 93 0d 01 	sts	0x010D, r24
			IRReg &= ~set_d_FLAG;
     8ec:	80 91 0d 01 	lds	r24, 0x010D
     8f0:	8f 7e       	andi	r24, 0xEF	; 239
     8f2:	80 93 0d 01 	sts	0x010D, r24

			if     ((2< s_count)&&(s_count <6 )){		// T 
     8f6:	80 91 4c 01 	lds	r24, 0x014C
     8fa:	98 2f       	mov	r25, r24
     8fc:	93 50       	subi	r25, 0x03	; 3
     8fe:	93 30       	cpi	r25, 0x03	; 3
     900:	08 f4       	brcc	.+2      	; 0x904 <IrRecv+0xaa>
     902:	6c c0       	rjmp	.+216    	; 0x9dc <IrRecv+0x182>
				if((T_count ==32 )){
					T_data = ir_data[2];	IRReg |= IrRxdFLAG;	

				}
				
			} else if((5< s_count)&&(s_count <30)){		//3T
     904:	98 2f       	mov	r25, r24
     906:	96 50       	subi	r25, 0x06	; 6
     908:	98 31       	cpi	r25, 0x18	; 24
     90a:	08 f0       	brcs	.+2      	; 0x90e <IrRecv+0xb4>
     90c:	75 c0       	rjmp	.+234    	; 0x9f8 <IrRecv+0x19e>
				u08 tmmp;

				if(T_count<=8){	
     90e:	80 91 7b 01 	lds	r24, 0x017B
     912:	89 30       	cpi	r24, 0x09	; 9
     914:	e0 f4       	brcc	.+56     	; 0x94e <IrRecv+0xf4>
					tmmp = T_count-1;				ir_data[0] = ir_data[0] |(1<<tmmp);
     916:	30 91 7b 01 	lds	r19, 0x017B
     91a:	20 91 5c 01 	lds	r18, 0x015C
     91e:	31 50       	subi	r19, 0x01	; 1
     920:	81 e0       	ldi	r24, 0x01	; 1
     922:	90 e0       	ldi	r25, 0x00	; 0
     924:	02 c0       	rjmp	.+4      	; 0x92a <IrRecv+0xd0>
     926:	88 0f       	add	r24, r24
     928:	99 1f       	adc	r25, r25
     92a:	3a 95       	dec	r19
     92c:	e2 f7       	brpl	.-8      	; 0x926 <IrRecv+0xcc>
     92e:	28 2b       	or	r18, r24
     930:	20 93 5c 01 	sts	0x015C, r18
					
					if(T_count == 8){					// 다자간 게임모드 데이터...
     934:	80 91 7b 01 	lds	r24, 0x017B
     938:	88 30       	cpi	r24, 0x08	; 8
     93a:	09 f0       	breq	.+2      	; 0x93e <IrRecv+0xe4>
     93c:	61 c0       	rjmp	.+194    	; 0xa00 <IrRecv+0x1a6>
						MultiCommData = ir_data[0];
     93e:	80 91 5c 01 	lds	r24, 0x015C
     942:	80 93 54 01 	sts	0x0154, r24
						IRReg |= MULTIRXDFLAG;
     946:	80 91 0d 01 	lds	r24, 0x010D
     94a:	81 60       	ori	r24, 0x01	; 1
     94c:	52 c0       	rjmp	.+164    	; 0x9f2 <IrRecv+0x198>
					}

				} else if((T_count>8)&&(T_count<=16)){
     94e:	80 91 7b 01 	lds	r24, 0x017B
     952:	89 30       	cpi	r24, 0x09	; 9
     954:	a0 f0       	brcs	.+40     	; 0x97e <IrRecv+0x124>
     956:	80 91 7b 01 	lds	r24, 0x017B
     95a:	81 31       	cpi	r24, 0x11	; 17
     95c:	80 f4       	brcc	.+32     	; 0x97e <IrRecv+0x124>
					tmmp = T_count-9;				ir_data[1] = ir_data[1] |(1<<tmmp); 
     95e:	30 91 7b 01 	lds	r19, 0x017B
     962:	20 91 5d 01 	lds	r18, 0x015D
     966:	39 50       	subi	r19, 0x09	; 9
     968:	81 e0       	ldi	r24, 0x01	; 1
     96a:	90 e0       	ldi	r25, 0x00	; 0
     96c:	02 c0       	rjmp	.+4      	; 0x972 <IrRecv+0x118>
     96e:	88 0f       	add	r24, r24
     970:	99 1f       	adc	r25, r25
     972:	3a 95       	dec	r19
     974:	e2 f7       	brpl	.-8      	; 0x96e <IrRecv+0x114>
     976:	28 2b       	or	r18, r24
     978:	20 93 5d 01 	sts	0x015D, r18
     97c:	41 c0       	rjmp	.+130    	; 0xa00 <IrRecv+0x1a6>
					
				} else if((T_count>16)&&(T_count<=24)){
     97e:	80 91 7b 01 	lds	r24, 0x017B
     982:	81 31       	cpi	r24, 0x11	; 17
     984:	a0 f0       	brcs	.+40     	; 0x9ae <IrRecv+0x154>
     986:	80 91 7b 01 	lds	r24, 0x017B
     98a:	89 31       	cpi	r24, 0x19	; 25
     98c:	80 f4       	brcc	.+32     	; 0x9ae <IrRecv+0x154>
					tmmp = T_count-17;				ir_data[2] = ir_data[2] |(1<<tmmp); 
     98e:	30 91 7b 01 	lds	r19, 0x017B
     992:	20 91 5e 01 	lds	r18, 0x015E
     996:	31 51       	subi	r19, 0x11	; 17
     998:	81 e0       	ldi	r24, 0x01	; 1
     99a:	90 e0       	ldi	r25, 0x00	; 0
     99c:	02 c0       	rjmp	.+4      	; 0x9a2 <IrRecv+0x148>
     99e:	88 0f       	add	r24, r24
     9a0:	99 1f       	adc	r25, r25
     9a2:	3a 95       	dec	r19
     9a4:	e2 f7       	brpl	.-8      	; 0x99e <IrRecv+0x144>
     9a6:	28 2b       	or	r18, r24
     9a8:	20 93 5e 01 	sts	0x015E, r18
     9ac:	29 c0       	rjmp	.+82     	; 0xa00 <IrRecv+0x1a6>
					
				} else if((T_count>24)&&(T_count<=32)){
     9ae:	80 91 7b 01 	lds	r24, 0x017B
     9b2:	89 31       	cpi	r24, 0x19	; 25
     9b4:	28 f1       	brcs	.+74     	; 0xa00 <IrRecv+0x1a6>
     9b6:	80 91 7b 01 	lds	r24, 0x017B
     9ba:	81 32       	cpi	r24, 0x21	; 33
     9bc:	08 f5       	brcc	.+66     	; 0xa00 <IrRecv+0x1a6>
					tmmp = T_count-25;				ir_data[3] = ir_data[3] |(1<<tmmp); 
     9be:	30 91 7b 01 	lds	r19, 0x017B
     9c2:	20 91 5f 01 	lds	r18, 0x015F
     9c6:	39 51       	subi	r19, 0x19	; 25
     9c8:	81 e0       	ldi	r24, 0x01	; 1
     9ca:	90 e0       	ldi	r25, 0x00	; 0
     9cc:	02 c0       	rjmp	.+4      	; 0x9d2 <IrRecv+0x178>
     9ce:	88 0f       	add	r24, r24
     9d0:	99 1f       	adc	r25, r25
     9d2:	3a 95       	dec	r19
     9d4:	e2 f7       	brpl	.-8      	; 0x9ce <IrRecv+0x174>
     9d6:	28 2b       	or	r18, r24
     9d8:	20 93 5f 01 	sts	0x015F, r18
														// 송신완료
					if((T_count ==32 )){
     9dc:	80 91 7b 01 	lds	r24, 0x017B
     9e0:	80 32       	cpi	r24, 0x20	; 32
     9e2:	71 f4       	brne	.+28     	; 0xa00 <IrRecv+0x1a6>
						T_data = ir_data[2];	IRReg |= IrRxdFLAG;	
     9e4:	80 91 5e 01 	lds	r24, 0x015E
     9e8:	80 93 ef 01 	sts	0x01EF, r24
     9ec:	80 91 0d 01 	lds	r24, 0x010D
     9f0:	80 68       	ori	r24, 0x80	; 128
     9f2:	80 93 0d 01 	sts	0x010D, r24
     9f6:	04 c0       	rjmp	.+8      	; 0xa00 <IrRecv+0x1a6>
//						RComFlagReg &= ~ExclRxFLAG;
					}
				}


			} else if((29< s_count)/*&&(s_count<45)*/){	//4T
     9f8:	8e 31       	cpi	r24, 0x1E	; 30
     9fa:	10 f0       	brcs	.+4      	; 0xa00 <IrRecv+0x1a6>
				T_count=0;							
     9fc:	10 92 7b 01 	sts	0x017B, r1
			}
			c_count = 0;
     a00:	10 92 4d 01 	sts	0x014D, r1
		} 
		
		if(!(c_count > 250)) c_count++ ;
     a04:	80 91 4d 01 	lds	r24, 0x014D
     a08:	8b 3f       	cpi	r24, 0xFB	; 251
     a0a:	18 f4       	brcc	.+6      	; 0xa12 <IrRecv+0x1b8>
     a0c:	8f 5f       	subi	r24, 0xFF	; 255
     a0e:	80 93 4d 01 	sts	0x014D, r24
		s_count = 0;	
     a12:	10 92 4c 01 	sts	0x014C, r1
	}// else
	if(RemoconValuedelayCnt){
     a16:	80 91 47 01 	lds	r24, 0x0147
     a1a:	88 23       	and	r24, r24
     a1c:	71 f0       	breq	.+28     	; 0xa3a <IrRecv+0x1e0>
		if(RemoconValuedelayCnt == 1){
     a1e:	80 91 47 01 	lds	r24, 0x0147
     a22:	81 30       	cpi	r24, 0x01	; 1
     a24:	29 f4       	brne	.+10     	; 0xa30 <IrRecv+0x1d6>
			IRReg&= ~IrRxdFLAG;
     a26:	80 91 0d 01 	lds	r24, 0x010D
     a2a:	8f 77       	andi	r24, 0x7F	; 127
     a2c:	80 93 0d 01 	sts	0x010D, r24
		}
		RemoconValuedelayCnt--;
     a30:	80 91 47 01 	lds	r24, 0x0147
     a34:	81 50       	subi	r24, 0x01	; 1
     a36:	80 93 47 01 	sts	0x0147, r24
     a3a:	08 95       	ret

00000a3c <IrComm>:
}

//---------------------------------------------------------
void IrComm(void)
{
	if(IRReg&IrTimeFLAG){//timer0 ovf(주기 64 *2) = 128usec 생성
     a3c:	80 91 0d 01 	lds	r24, 0x010D
     a40:	86 ff       	sbrs	r24, 6
     a42:	06 c0       	rjmp	.+12     	; 0xa50 <IrComm+0x14>
		IrRecv();
     a44:	0e 94 2d 04 	call	0x85a	; 0x85a <IrRecv>
		IRReg &= ~IrTimeFLAG; 	
     a48:	80 91 0d 01 	lds	r24, 0x010D
     a4c:	8f 7b       	andi	r24, 0xBF	; 191
     a4e:	03 c0       	rjmp	.+6      	; 0xa56 <IrComm+0x1a>
	} else {
		//IrTransmit();
		IRReg |= IrTimeFLAG;
     a50:	80 91 0d 01 	lds	r24, 0x010D
     a54:	80 64       	ori	r24, 0x40	; 64
     a56:	80 93 0d 01 	sts	0x010D, r24
     a5a:	08 95       	ret

00000a5c <DcMotor_temp>:

void DcMotor_temp(u08 direction ,u08 sel_motor, u08 pwm_value){
	
// cur_pwm[2], org_pwm[2], pwm_cycle, pwm_cnt

		sbi(DDRB,4);
     a5c:	bc 9a       	sbi	0x17, 4	; 23
		sbi(DDRB,5);
     a5e:	bd 9a       	sbi	0x17, 5	; 23
		sbi(DDRE,4);
     a60:	14 9a       	sbi	0x02, 4	; 2
		sbi(DDRB,6);
     a62:	be 9a       	sbi	0x17, 6	; 23
		sbi(DDRB,7);
     a64:	bf 9a       	sbi	0x17, 7	; 23
		sbi(DDRE,5);
     a66:	15 9a       	sbi	0x02, 5	; 2
	
	if(sel_motor == 1) 			// right_motor
     a68:	61 30       	cpi	r22, 0x01	; 1
     a6a:	a9 f4       	brne	.+42     	; 0xa96 <DcMotor_temp+0x3a>
	{
		if(direction == 1){		// 정방향		
     a6c:	81 30       	cpi	r24, 0x01	; 1
     a6e:	19 f4       	brne	.+6      	; 0xa76 <DcMotor_temp+0x1a>
			cbi(PORTB,4);
     a70:	c4 98       	cbi	0x18, 4	; 24
			sbi(PORTB,5);
     a72:	c5 9a       	sbi	0x18, 5	; 24
     a74:	04 c0       	rjmp	.+8      	; 0xa7e <DcMotor_temp+0x22>
		}else if(direction == 0){// 역방향
     a76:	88 23       	and	r24, r24
     a78:	11 f4       	brne	.+4      	; 0xa7e <DcMotor_temp+0x22>
			cbi(PORTB,5);
     a7a:	c5 98       	cbi	0x18, 5	; 24
			sbi(PORTB,4);
     a7c:	c4 9a       	sbi	0x18, 4	; 24
		}
		org_pwm[0] = pwm_value;
     a7e:	40 93 41 01 	sts	0x0141, r20
		if(org_pwm[0]){
     a82:	80 91 41 01 	lds	r24, 0x0141
     a86:	88 23       	and	r24, r24
     a88:	19 f0       	breq	.+6      	; 0xa90 <DcMotor_temp+0x34>
			org_pwm[0] = pwm_value;
     a8a:	40 93 41 01 	sts	0x0141, r20
     a8e:	08 95       	ret
		} else {
			cbi(PORTB,4);
     a90:	c4 98       	cbi	0x18, 4	; 24
			cbi(PORTB,5);
     a92:	c5 98       	cbi	0x18, 5	; 24
     a94:	08 95       	ret
		}
	}
	else if(sel_motor == 2)		// left_motor
     a96:	62 30       	cpi	r22, 0x02	; 2
     a98:	91 f4       	brne	.+36     	; 0xabe <DcMotor_temp+0x62>
	{	
		if(direction == 1){		// 정방향
     a9a:	81 30       	cpi	r24, 0x01	; 1
     a9c:	19 f4       	brne	.+6      	; 0xaa4 <DcMotor_temp+0x48>
			cbi(PORTB,7);
     a9e:	c7 98       	cbi	0x18, 7	; 24
			sbi(PORTB,6);
     aa0:	c6 9a       	sbi	0x18, 6	; 24
     aa2:	04 c0       	rjmp	.+8      	; 0xaac <DcMotor_temp+0x50>
		}else if(direction == 0){// 역방향
     aa4:	88 23       	and	r24, r24
     aa6:	11 f4       	brne	.+4      	; 0xaac <DcMotor_temp+0x50>
			cbi(PORTB,6);
     aa8:	c6 98       	cbi	0x18, 6	; 24
			sbi(PORTB,7);
     aaa:	c7 9a       	sbi	0x18, 7	; 24
		}
		org_pwm[1] = pwm_value;
     aac:	40 93 42 01 	sts	0x0142, r20
		if(org_pwm[1]){
     ab0:	80 91 42 01 	lds	r24, 0x0142
     ab4:	88 23       	and	r24, r24
     ab6:	41 f5       	brne	.+80     	; 0xb08 <DcMotor_temp+0xac>
			org_pwm[1] = pwm_value;		
		}else {
			cbi(PORTB,6);
     ab8:	c6 98       	cbi	0x18, 6	; 24
			cbi(PORTB,7);
     aba:	c7 98       	cbi	0x18, 7	; 24
     abc:	08 95       	ret
		}
	}	
	else if(sel_motor == 3)		// 양쪽모터
     abe:	63 30       	cpi	r22, 0x03	; 3
     ac0:	41 f5       	brne	.+80     	; 0xb12 <DcMotor_temp+0xb6>
	{
		if(direction == 1){		// 정방향
     ac2:	81 30       	cpi	r24, 0x01	; 1
     ac4:	19 f4       	brne	.+6      	; 0xacc <DcMotor_temp+0x70>
			
			cbi(PORTB,4);
     ac6:	c4 98       	cbi	0x18, 4	; 24
			sbi(PORTB,5);
     ac8:	c5 9a       	sbi	0x18, 5	; 24
     aca:	04 c0       	rjmp	.+8      	; 0xad4 <DcMotor_temp+0x78>
		}else if(direction == 0){// 역방향
     acc:	88 23       	and	r24, r24
     ace:	11 f4       	brne	.+4      	; 0xad4 <DcMotor_temp+0x78>
			cbi(PORTB,5);
     ad0:	c5 98       	cbi	0x18, 5	; 24
			sbi(PORTB,4);
     ad2:	c4 9a       	sbi	0x18, 4	; 24
		}
		org_pwm[0] = pwm_value;
     ad4:	40 93 41 01 	sts	0x0141, r20
		if(org_pwm[0]){
     ad8:	90 91 41 01 	lds	r25, 0x0141
     adc:	99 23       	and	r25, r25
     ade:	19 f0       	breq	.+6      	; 0xae6 <DcMotor_temp+0x8a>
			org_pwm[0] = pwm_value;
     ae0:	40 93 41 01 	sts	0x0141, r20
     ae4:	02 c0       	rjmp	.+4      	; 0xaea <DcMotor_temp+0x8e>
		} else {
			cbi(PORTB,4);
     ae6:	c4 98       	cbi	0x18, 4	; 24
			cbi(PORTB,5);
     ae8:	c5 98       	cbi	0x18, 5	; 24
		}
	
		if(direction == 1){		// 정방향
     aea:	81 30       	cpi	r24, 0x01	; 1
     aec:	19 f4       	brne	.+6      	; 0xaf4 <DcMotor_temp+0x98>
			cbi(PORTB,7);
     aee:	c7 98       	cbi	0x18, 7	; 24
			sbi(PORTB,6);
     af0:	c6 9a       	sbi	0x18, 6	; 24
     af2:	04 c0       	rjmp	.+8      	; 0xafc <DcMotor_temp+0xa0>
		}else if(direction == 0){// 역방향
     af4:	88 23       	and	r24, r24
     af6:	11 f4       	brne	.+4      	; 0xafc <DcMotor_temp+0xa0>
			cbi(PORTB,6);
     af8:	c6 98       	cbi	0x18, 6	; 24
			sbi(PORTB,7);
     afa:	c7 9a       	sbi	0x18, 7	; 24
		}
		org_pwm[1] = pwm_value;
     afc:	40 93 42 01 	sts	0x0142, r20
		if(org_pwm[1]){
     b00:	80 91 42 01 	lds	r24, 0x0142
     b04:	88 23       	and	r24, r24
     b06:	19 f0       	breq	.+6      	; 0xb0e <DcMotor_temp+0xb2>
			org_pwm[1] = pwm_value;		
     b08:	40 93 42 01 	sts	0x0142, r20
     b0c:	08 95       	ret
		}else {
			cbi(PORTB,6);
     b0e:	c6 98       	cbi	0x18, 6	; 24
			cbi(PORTB,7);
     b10:	c7 98       	cbi	0x18, 7	; 24
     b12:	08 95       	ret

00000b14 <isr_pwm>:
//---------------------------------------------------------
void isr_pwm(void)
{
	// cur_pwm[2], org_pwm[2], pwm_cycle, pwm_cnt

	pwm_cnt++;
     b14:	80 91 43 01 	lds	r24, 0x0143
     b18:	8f 5f       	subi	r24, 0xFF	; 255
     b1a:	80 93 43 01 	sts	0x0143, r24
		
	if(pwm_cnt == pwm_cycle){
     b1e:	90 91 43 01 	lds	r25, 0x0143
     b22:	80 91 0c 01 	lds	r24, 0x010C
     b26:	98 17       	cp	r25, r24
     b28:	91 f4       	brne	.+36     	; 0xb4e <isr_pwm+0x3a>
		pwm_cnt = 0;	
     b2a:	10 92 43 01 	sts	0x0143, r1
		cur_pwm[0] = org_pwm[0];
     b2e:	80 91 41 01 	lds	r24, 0x0141
     b32:	80 93 3f 01 	sts	0x013F, r24
		cur_pwm[1] = org_pwm[1];
     b36:	80 91 42 01 	lds	r24, 0x0142
     b3a:	80 93 40 01 	sts	0x0140, r24
		
		if(cur_pwm[0]){		// right 동작
     b3e:	80 91 3f 01 	lds	r24, 0x013F
     b42:	81 11       	cpse	r24, r1
			sbi(PORTE,4);
     b44:	1c 9a       	sbi	0x03, 4	; 3
		}
		if(cur_pwm[1]){		// left 동작
     b46:	80 91 40 01 	lds	r24, 0x0140
     b4a:	81 11       	cpse	r24, r1
			sbi(PORTE,5);
     b4c:	1d 9a       	sbi	0x03, 5	; 3
		}
	}
	
	if(pwm_cnt == cur_pwm[0]){		// right_정지
     b4e:	90 91 43 01 	lds	r25, 0x0143
     b52:	80 91 3f 01 	lds	r24, 0x013F
     b56:	98 17       	cp	r25, r24
     b58:	09 f4       	brne	.+2      	; 0xb5c <isr_pwm+0x48>
			cbi(PORTE,4);
     b5a:	1c 98       	cbi	0x03, 4	; 3
	}	
	if(pwm_cnt == cur_pwm[1]){		// left_정지
     b5c:	90 91 43 01 	lds	r25, 0x0143
     b60:	80 91 40 01 	lds	r24, 0x0140
     b64:	98 17       	cp	r25, r24
     b66:	09 f4       	brne	.+2      	; 0xb6a <isr_pwm+0x56>
			cbi(PORTE,5);
     b68:	1d 98       	cbi	0x03, 5	; 3
     b6a:	08 95       	ret

00000b6c <PhotoSensorUpdate>:
//---------------------------------------------------------
void PhotoSensorUpdate()
{
    static u08 timingcnt;	//읽은 센서값을 카운터 시간 지연을 줌
    
	timingcnt++;
     b6c:	80 91 4b 01 	lds	r24, 0x014B
     b70:	8f 5f       	subi	r24, 0xFF	; 255
     b72:	80 93 4b 01 	sts	0x014B, r24
	
	if(timingcnt == 16){
     b76:	80 31       	cpi	r24, 0x10	; 16
     b78:	19 f4       	brne	.+6      	; 0xb80 <PhotoSensorUpdate+0x14>
	    timingcnt = 0;	
     b7a:	10 92 4b 01 	sts	0x014B, r1
     b7e:	08 95       	ret
	
	}else if(timingcnt == 14){
     b80:	8e 30       	cpi	r24, 0x0E	; 14
     b82:	11 f4       	brne	.+4      	; 0xb88 <PhotoSensorUpdate+0x1c>
		// 센서 발광 시작
		sbi(PORTC, SENS_TRIG);				
     b84:	ae 9a       	sbi	0x15, 6	; 21
     b86:	08 95       	ret
		
	}else if(timingcnt == 15){
     b88:	8f 30       	cpi	r24, 0x0F	; 15
     b8a:	b9 f4       	brne	.+46     	; 0xbba <PhotoSensorUpdate+0x4e>
		//센서수광, 값읽음	
		
		//
		if(SensorDir == FORWARD){
     b8c:	80 91 60 01 	lds	r24, 0x0160
     b90:	81 30       	cpi	r24, 0x01	; 1
     b92:	29 f4       	brne	.+10     	; 0xb9e <PhotoSensorUpdate+0x32>
  		    ForwardPhotoSensor = inp(PINC)& 0x07;			//전방센서	
     b94:	83 b3       	in	r24, 0x13	; 19
     b96:	87 70       	andi	r24, 0x07	; 7
     b98:	80 93 78 01 	sts	0x0178, r24
     b9c:	0d c0       	rjmp	.+26     	; 0xbb8 <PhotoSensorUpdate+0x4c>
  		}else{
  		    DownwardPhotoSensor = //(inp(PINC)>>3)&0x07;
  		     (~((inp(PINC)&( 0x38))>> 3))&0x07;	//하방센서			
     b9e:	83 b3       	in	r24, 0x13	; 19
     ba0:	90 e0       	ldi	r25, 0x00	; 0
     ba2:	88 73       	andi	r24, 0x38	; 56
     ba4:	90 70       	andi	r25, 0x00	; 0
     ba6:	23 e0       	ldi	r18, 0x03	; 3
     ba8:	95 95       	asr	r25
     baa:	87 95       	ror	r24
     bac:	2a 95       	dec	r18
     bae:	e1 f7       	brne	.-8      	; 0xba8 <PhotoSensorUpdate+0x3c>
		
		//
		if(SensorDir == FORWARD){
  		    ForwardPhotoSensor = inp(PINC)& 0x07;			//전방센서	
  		}else{
  		    DownwardPhotoSensor = //(inp(PINC)>>3)&0x07;
     bb0:	80 95       	com	r24
     bb2:	87 70       	andi	r24, 0x07	; 7
     bb4:	80 93 55 01 	sts	0x0155, r24
  		     (~((inp(PINC)&( 0x38))>> 3))&0x07;	//하방센서			
  		} 
  		  		  		
  		cbi(PORTC, SENS_TRIG);	//센서 발광 끝	  			  		
     bb8:	ae 98       	cbi	0x15, 6	; 21
     bba:	08 95       	ret

00000bbc <__vector_16>:

/******************************************************************************
 타이머 인터럽트는 0.125us 마다 발생한다. 
******************************************************************************/
SIGNAL(SIG_OVERFLOW0)
{						//32uS 마다 진입
     bbc:	1f 92       	push	r1
     bbe:	0f 92       	push	r0
     bc0:	0f b6       	in	r0, 0x3f	; 63
     bc2:	0f 92       	push	r0
     bc4:	11 24       	eor	r1, r1
     bc6:	2f 93       	push	r18
     bc8:	3f 93       	push	r19
     bca:	4f 93       	push	r20
     bcc:	5f 93       	push	r21
     bce:	6f 93       	push	r22
     bd0:	7f 93       	push	r23
     bd2:	8f 93       	push	r24
     bd4:	9f 93       	push	r25
     bd6:	af 93       	push	r26
     bd8:	bf 93       	push	r27
     bda:	ef 93       	push	r30
     bdc:	ff 93       	push	r31
	static u08 mux2 = 0;
  	static u08 cntTick = 4;
  	static u08 cntMotor = 0;
  	static u08 Pwmloopcnt = 0;  //
 			 		 	 	
 	if(mux2){      //64uS 마다 진입
     bde:	80 91 53 01 	lds	r24, 0x0153
     be2:	88 23       	and	r24, r24
     be4:	29 f1       	breq	.+74     	; 0xc30 <__vector_16+0x74>
 	    mux2 = 0;
     be6:	10 92 53 01 	sts	0x0153, r1
     	IrComm(); 
     bea:	0e 94 1e 05 	call	0xa3c	; 0xa3c <IrComm>
     	MelFunc();         	
     bee:	0e 94 48 02 	call	0x490	; 0x490 <MelFunc>
		   
		if(delay_count != 0){	
     bf2:	80 91 79 01 	lds	r24, 0x0179
     bf6:	90 91 7a 01 	lds	r25, 0x017A
     bfa:	00 97       	sbiw	r24, 0x00	; 0
     bfc:	49 f0       	breq	.+18     	; 0xc10 <__vector_16+0x54>
			delay_count--;
     bfe:	80 91 79 01 	lds	r24, 0x0179
     c02:	90 91 7a 01 	lds	r25, 0x017A
     c06:	01 97       	sbiw	r24, 0x01	; 1
     c08:	90 93 7a 01 	sts	0x017A, r25
     c0c:	80 93 79 01 	sts	0x0179, r24
		}
		if(delayms_count != 0){
     c10:	80 91 bd 01 	lds	r24, 0x01BD
     c14:	90 91 be 01 	lds	r25, 0x01BE
     c18:	00 97       	sbiw	r24, 0x00	; 0
     c1a:	19 f1       	breq	.+70     	; 0xc62 <__vector_16+0xa6>
			delayms_count--;
     c1c:	80 91 bd 01 	lds	r24, 0x01BD
     c20:	90 91 be 01 	lds	r25, 0x01BE
     c24:	01 97       	sbiw	r24, 0x01	; 1
     c26:	90 93 be 01 	sts	0x01BE, r25
     c2a:	80 93 bd 01 	sts	0x01BD, r24
     c2e:	19 c0       	rjmp	.+50     	; 0xc62 <__vector_16+0xa6>
		}
			
 	}else{	
		mux2 = 1;					///// ControlPortc == 1 포토센서.
     c30:	81 e0       	ldi	r24, 0x01	; 1
     c32:	80 93 53 01 	sts	0x0153, r24
		if(ControlPortc == 1)  PhotoSensorUpdate();     ///// 2007.03.13 추가. (불도저 or 포토센서)
     c36:	80 91 3e 01 	lds	r24, 0x013E
     c3a:	81 30       	cpi	r24, 0x01	; 1
     c3c:	11 f4       	brne	.+4      	; 0xc42 <__vector_16+0x86>
     c3e:	0e 94 b6 05 	call	0xb6c	; 0xb6c <PhotoSensorUpdate>

		if(Pwmloopcnt == 0){	// PWM 루틴	
     c42:	80 91 52 01 	lds	r24, 0x0152
     c46:	88 23       	and	r24, r24
     c48:	29 f4       	brne	.+10     	; 0xc54 <__vector_16+0x98>
		    Pwmloopcnt = 2;	    
     c4a:	82 e0       	ldi	r24, 0x02	; 2
     c4c:	80 93 52 01 	sts	0x0152, r24
			isr_pwm();
     c50:	0e 94 8a 05 	call	0xb14	; 0xb14 <isr_pwm>
		}

		--Pwmloopcnt;		
     c54:	80 91 52 01 	lds	r24, 0x0152
     c58:	81 50       	subi	r24, 0x01	; 1
     c5a:	80 93 52 01 	sts	0x0152, r24
		ClkTickFunc();		// 	CLK Genarate Zone 	   	
     c5e:	0e 94 15 01 	call	0x22a	; 0x22a <ClkTickFunc>
	}

	if(delay32us != 0) delay32us--;
     c62:	80 91 7d 01 	lds	r24, 0x017D
     c66:	90 91 7e 01 	lds	r25, 0x017E
     c6a:	00 97       	sbiw	r24, 0x00	; 0
     c6c:	49 f0       	breq	.+18     	; 0xc80 <__vector_16+0xc4>
     c6e:	80 91 7d 01 	lds	r24, 0x017D
     c72:	90 91 7e 01 	lds	r25, 0x017E
     c76:	01 97       	sbiw	r24, 0x01	; 1
     c78:	90 93 7e 01 	sts	0x017E, r25
     c7c:	80 93 7d 01 	sts	0x017D, r24
	if(delay32us < 0 ) delay32us =0;
     c80:	80 91 7d 01 	lds	r24, 0x017D
     c84:	90 91 7e 01 	lds	r25, 0x017E
	
}
     c88:	ff 91       	pop	r31
     c8a:	ef 91       	pop	r30
     c8c:	bf 91       	pop	r27
     c8e:	af 91       	pop	r26
     c90:	9f 91       	pop	r25
     c92:	8f 91       	pop	r24
     c94:	7f 91       	pop	r23
     c96:	6f 91       	pop	r22
     c98:	5f 91       	pop	r21
     c9a:	4f 91       	pop	r20
     c9c:	3f 91       	pop	r19
     c9e:	2f 91       	pop	r18
     ca0:	0f 90       	pop	r0
     ca2:	0f be       	out	0x3f, r0	; 63
     ca4:	0f 90       	pop	r0
     ca6:	1f 90       	pop	r1
     ca8:	18 95       	reti

00000caa <delayms>:
void delayms(unsigned int delay_ms)
{
    for(;delay_ms>0;delay_ms--)
	{
        while(delayms_count > 0){}
		delayms_count = 16;
     caa:	20 e1       	ldi	r18, 0x10	; 16
     cac:	30 e0       	ldi	r19, 0x00	; 0
//////////////////////////////////////////////////////////////////////////////////////
//@@@@@@@@@@@@@@@ 07.03.28 @@@@@@@@@@@@@@@@@@@@//

void delayms(unsigned int delay_ms)
{
    for(;delay_ms>0;delay_ms--)
     cae:	0c c0       	rjmp	.+24     	; 0xcc8 <delayms+0x1e>
	{
        while(delayms_count > 0){}
     cb0:	40 91 bd 01 	lds	r20, 0x01BD
     cb4:	50 91 be 01 	lds	r21, 0x01BE
     cb8:	41 15       	cp	r20, r1
     cba:	51 05       	cpc	r21, r1
     cbc:	c9 f7       	brne	.-14     	; 0xcb0 <delayms+0x6>
		delayms_count = 16;
     cbe:	30 93 be 01 	sts	0x01BE, r19
     cc2:	20 93 bd 01 	sts	0x01BD, r18
//////////////////////////////////////////////////////////////////////////////////////
//@@@@@@@@@@@@@@@ 07.03.28 @@@@@@@@@@@@@@@@@@@@//

void delayms(unsigned int delay_ms)
{
    for(;delay_ms>0;delay_ms--)
     cc6:	01 97       	sbiw	r24, 0x01	; 1
     cc8:	00 97       	sbiw	r24, 0x00	; 0
     cca:	91 f7       	brne	.-28     	; 0xcb0 <delayms+0x6>
	{
        while(delayms_count > 0){}
		delayms_count = 16;
    }
}
     ccc:	08 95       	ret

00000cce <delay_cho>:
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@//


void delay_cho(void)
{
    while(delay_count > 0){
     cce:	80 91 79 01 	lds	r24, 0x0179
     cd2:	90 91 7a 01 	lds	r25, 0x017A
     cd6:	00 97       	sbiw	r24, 0x00	; 0
     cd8:	d1 f7       	brne	.-12     	; 0xcce <delay_cho>
    }
	delay_count = 16;
     cda:	80 e1       	ldi	r24, 0x10	; 16
     cdc:	90 e0       	ldi	r25, 0x00	; 0
     cde:	90 93 7a 01 	sts	0x017A, r25
     ce2:	80 93 79 01 	sts	0x0179, r24
}
     ce6:	08 95       	ret

00000ce8 <delay>:

//---------------------------------------------------------
void delay(unsigned int delay_cnt)
{
	
	delay32us = 1;
     ce8:	21 e0       	ldi	r18, 0x01	; 1
     cea:	30 e0       	ldi	r19, 0x00	; 0
     cec:	30 93 7e 01 	sts	0x017E, r19
     cf0:	20 93 7d 01 	sts	0x017D, r18
	
	for(;delay_cnt>0;delay_cnt--)
     cf4:	0c c0       	rjmp	.+24     	; 0xd0e <delay+0x26>
	{
		while(delay32us>0);
     cf6:	40 91 7d 01 	lds	r20, 0x017D
     cfa:	50 91 7e 01 	lds	r21, 0x017E
     cfe:	41 15       	cp	r20, r1
     d00:	51 05       	cpc	r21, r1
     d02:	c9 f7       	brne	.-14     	; 0xcf6 <delay+0xe>
		delay32us = 1;
     d04:	30 93 7e 01 	sts	0x017E, r19
     d08:	20 93 7d 01 	sts	0x017D, r18
void delay(unsigned int delay_cnt)
{
	
	delay32us = 1;
	
	for(;delay_cnt>0;delay_cnt--)
     d0c:	01 97       	sbiw	r24, 0x01	; 1
     d0e:	00 97       	sbiw	r24, 0x00	; 0
     d10:	91 f7       	brne	.-28     	; 0xcf6 <delay+0xe>
		while(delay32us>0);
		delay32us = 1;
	}   


}
     d12:	08 95       	ret

00000d14 <mSecDelay>:

//---------------------------------------------------------
void mSecDelay(unsigned int delay_ms)  
{
     d14:	cf 93       	push	r28
     d16:	df 93       	push	r29
	
    unsigned int delayms;
    
    delay_count = 16;
     d18:	20 e1       	ldi	r18, 0x10	; 16
     d1a:	30 e0       	ldi	r19, 0x00	; 0
     d1c:	30 93 7a 01 	sts	0x017A, r19
     d20:	20 93 79 01 	sts	0x0179, r18
		
    delayms=delay_ms*100;
     d24:	24 e6       	ldi	r18, 0x64	; 100
     d26:	30 e0       	ldi	r19, 0x00	; 0
     d28:	82 9f       	mul	r24, r18
     d2a:	e0 01       	movw	r28, r0
     d2c:	83 9f       	mul	r24, r19
     d2e:	d0 0d       	add	r29, r0
     d30:	92 9f       	mul	r25, r18
     d32:	d0 0d       	add	r29, r0
     d34:	11 24       	eor	r1, r1
		
    for(;delayms>0;delayms--){
     d36:	03 c0       	rjmp	.+6      	; 0xd3e <mSecDelay+0x2a>
        delay_cho();		//delay(920);
     d38:	0e 94 67 06 	call	0xcce	; 0xcce <delay_cho>
    
    delay_count = 16;
		
    delayms=delay_ms*100;
		
    for(;delayms>0;delayms--){
     d3c:	21 97       	sbiw	r28, 0x01	; 1
     d3e:	20 97       	sbiw	r28, 0x00	; 0
     d40:	d9 f7       	brne	.-10     	; 0xd38 <mSecDelay+0x24>
        delay_cho();		//delay(920);
    }
	
}
     d42:	df 91       	pop	r29
     d44:	cf 91       	pop	r28
     d46:	08 95       	ret

00000d48 <lcd_port_init>:
//LCD 관련함수
//////////////////////////////////////////////////////////////////////////////////////
void lcd_port_init(void)
{
    //Port Initialization
    outp(0xFF, LCD_C_INOUT);
     d48:	8f ef       	ldi	r24, 0xFF	; 255
     d4a:	80 93 64 00 	sts	0x0064, r24
    outp(0xFF, LCD_D_INOUT);
     d4e:	8a bb       	out	0x1a, r24	; 26
    outp(0x00, LCD_CONTROL);
     d50:	10 92 65 00 	sts	0x0065, r1
    outp(0x00, LCD_DATA);
     d54:	1b ba       	out	0x1b, r1	; 27
}
     d56:	08 95       	ret

00000d58 <command>:
        command(LCD_D_CLR);     // There must be!
}

//---------------------------------------------------------
void command(unsigned char cmd)
{
     d58:	1f 93       	push	r17
     d5a:	cf 93       	push	r28
     d5c:	df 93       	push	r29
     d5e:	18 2f       	mov	r17, r24
    delay(5);
     d60:	85 e0       	ldi	r24, 0x05	; 5
     d62:	90 e0       	ldi	r25, 0x00	; 0
     d64:	0e 94 74 06 	call	0xce8	; 0xce8 <delay>
    outp(0x04, PORTG);  
     d68:	c5 e6       	ldi	r28, 0x65	; 101
     d6a:	d0 e0       	ldi	r29, 0x00	; 0
     d6c:	84 e0       	ldi	r24, 0x04	; 4
     d6e:	88 83       	st	Y, r24
    delay(5);
     d70:	85 e0       	ldi	r24, 0x05	; 5
     d72:	90 e0       	ldi	r25, 0x00	; 0
     d74:	0e 94 74 06 	call	0xce8	; 0xce8 <delay>
    outp(cmd,LCD_DATA);
     d78:	1b bb       	out	0x1b, r17	; 27
    delay(5);
     d7a:	85 e0       	ldi	r24, 0x05	; 5
     d7c:	90 e0       	ldi	r25, 0x00	; 0
     d7e:	0e 94 74 06 	call	0xce8	; 0xce8 <delay>
    outp(0x00, PORTG);
     d82:	18 82       	st	Y, r1
    delay(5);
     d84:	85 e0       	ldi	r24, 0x05	; 5
     d86:	90 e0       	ldi	r25, 0x00	; 0
     d88:	0e 94 74 06 	call	0xce8	; 0xce8 <delay>
}
     d8c:	df 91       	pop	r29
     d8e:	cf 91       	pop	r28
     d90:	1f 91       	pop	r17
     d92:	08 95       	ret

00000d94 <lcd_init>:
}

//---------------------------------------------------------
void lcd_init(void)		
{
    delay(625);       // Wait for more than 30ms
     d94:	81 e7       	ldi	r24, 0x71	; 113
     d96:	92 e0       	ldi	r25, 0x02	; 2
     d98:	0e 94 74 06 	call	0xce8	; 0xce8 <delay>
	
        command(LCD_SET_8); // Function Set
     d9c:	88 e3       	ldi	r24, 0x38	; 56
     d9e:	0e 94 ac 06 	call	0xd58	; 0xd58 <command>
	delay(63);			// 2ms 지연
     da2:	8f e3       	ldi	r24, 0x3F	; 63
     da4:	90 e0       	ldi	r25, 0x00	; 0
     da6:	0e 94 74 06 	call	0xce8	; 0xce8 <delay>
	command(LCD_SET_8);
     daa:	88 e3       	ldi	r24, 0x38	; 56
     dac:	0e 94 ac 06 	call	0xd58	; 0xd58 <command>
	delay(63);
     db0:	8f e3       	ldi	r24, 0x3F	; 63
     db2:	90 e0       	ldi	r25, 0x00	; 0
     db4:	0e 94 74 06 	call	0xce8	; 0xce8 <delay>
	command(LCD_D_ON);  // Display On/Off Control
     db8:	8c e0       	ldi	r24, 0x0C	; 12
     dba:	0e 94 ac 06 	call	0xd58	; 0xd58 <command>
        command(LCD_E_N);   // Entry Mode Set
     dbe:	86 e0       	ldi	r24, 0x06	; 6
     dc0:	0e 94 ac 06 	call	0xd58	; 0xd58 <command>
	command(LCD_D_CLR); // Display Clear
     dc4:	81 e0       	ldi	r24, 0x01	; 1
     dc6:	0e 94 ac 06 	call	0xd58	; 0xd58 <command>
        command(LCD_D_CLR);     // There must be!
     dca:	81 e0       	ldi	r24, 0x01	; 1
     dcc:	0e 94 ac 06 	call	0xd58	; 0xd58 <command>
}
     dd0:	08 95       	ret

00000dd2 <lcd_out>:
    delay(5);
}

//---------------------------------------------------------
void lcd_out(unsigned char data)
{
     dd2:	1f 93       	push	r17
     dd4:	cf 93       	push	r28
     dd6:	df 93       	push	r29
     dd8:	18 2f       	mov	r17, r24
    delay(5);
     dda:	85 e0       	ldi	r24, 0x05	; 5
     ddc:	90 e0       	ldi	r25, 0x00	; 0
     dde:	0e 94 74 06 	call	0xce8	; 0xce8 <delay>
    outp(0x05, PORTG);
     de2:	c5 e6       	ldi	r28, 0x65	; 101
     de4:	d0 e0       	ldi	r29, 0x00	; 0
     de6:	85 e0       	ldi	r24, 0x05	; 5
     de8:	88 83       	st	Y, r24
    delay(5);
     dea:	85 e0       	ldi	r24, 0x05	; 5
     dec:	90 e0       	ldi	r25, 0x00	; 0
     dee:	0e 94 74 06 	call	0xce8	; 0xce8 <delay>
    outp(data,LCD_DATA);
     df2:	1b bb       	out	0x1b, r17	; 27
    delay(5);
     df4:	85 e0       	ldi	r24, 0x05	; 5
     df6:	90 e0       	ldi	r25, 0x00	; 0
     df8:	0e 94 74 06 	call	0xce8	; 0xce8 <delay>
    outp(0x01, PORTG);
     dfc:	81 e0       	ldi	r24, 0x01	; 1
     dfe:	88 83       	st	Y, r24
    delay(5);
     e00:	85 e0       	ldi	r24, 0x05	; 5
     e02:	90 e0       	ldi	r25, 0x00	; 0
     e04:	0e 94 74 06 	call	0xce8	; 0xce8 <delay>
}
     e08:	df 91       	pop	r29
     e0a:	cf 91       	pop	r28
     e0c:	1f 91       	pop	r17
     e0e:	08 95       	ret

00000e10 <lcd_position>:

//---------------------------------------------------------
void lcd_position(unsigned char row, unsigned char col)
{
    char addr;
    addr=0x80+0x40*(row-1)+(col-1);
     e10:	82 95       	swap	r24
     e12:	88 0f       	add	r24, r24
     e14:	88 0f       	add	r24, r24
     e16:	80 7c       	andi	r24, 0xC0	; 192
     e18:	68 0f       	add	r22, r24
    command(addr);
     e1a:	86 2f       	mov	r24, r22
     e1c:	81 5c       	subi	r24, 0xC1	; 193
     e1e:	0e 94 ac 06 	call	0xd58	; 0xd58 <command>
}
     e22:	08 95       	ret

00000e24 <lcd_char_out>:

//---------------------------------------------------------
void lcd_char_out(unsigned char row, unsigned char col, unsigned char data)
{
     e24:	df 93       	push	r29
     e26:	cf 93       	push	r28
     e28:	0f 92       	push	r0
     e2a:	cd b7       	in	r28, 0x3d	; 61
     e2c:	de b7       	in	r29, 0x3e	; 62
    lcd_position(row,col);
     e2e:	49 83       	std	Y+1, r20	; 0x01
     e30:	0e 94 08 07 	call	0xe10	; 0xe10 <lcd_position>
    lcd_out(data);
     e34:	49 81       	ldd	r20, Y+1	; 0x01
     e36:	84 2f       	mov	r24, r20
     e38:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <lcd_out>
}
     e3c:	0f 90       	pop	r0
     e3e:	cf 91       	pop	r28
     e40:	df 91       	pop	r29
     e42:	08 95       	ret

00000e44 <lcd_str_out>:

//---------------------------------------------------------
void lcd_str_out(unsigned char row, unsigned char col, unsigned char *msg)
{
     e44:	ef 92       	push	r14
     e46:	ff 92       	push	r15
     e48:	0f 93       	push	r16
     e4a:	1f 93       	push	r17
     e4c:	df 93       	push	r29
     e4e:	cf 93       	push	r28
     e50:	00 d0       	rcall	.+0      	; 0xe52 <lcd_str_out+0xe>
     e52:	cd b7       	in	r28, 0x3d	; 61
     e54:	de b7       	in	r29, 0x3e	; 62
    lcd_position(row,col);
     e56:	49 83       	std	Y+1, r20	; 0x01
     e58:	5a 83       	std	Y+2, r21	; 0x02
     e5a:	0e 94 08 07 	call	0xe10	; 0xe10 <lcd_position>
     e5e:	49 81       	ldd	r20, Y+1	; 0x01
     e60:	5a 81       	ldd	r21, Y+2	; 0x02
     e62:	8a 01       	movw	r16, r20
    while(*msg){
     e64:	02 c0       	rjmp	.+4      	; 0xe6a <lcd_str_out+0x26>
        lcd_out(*(msg++));
     e66:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <lcd_out>

//---------------------------------------------------------
void lcd_str_out(unsigned char row, unsigned char col, unsigned char *msg)
{
    lcd_position(row,col);
    while(*msg){
     e6a:	f8 01       	movw	r30, r16
     e6c:	81 91       	ld	r24, Z+
     e6e:	8f 01       	movw	r16, r30
     e70:	88 23       	and	r24, r24
     e72:	c9 f7       	brne	.-14     	; 0xe66 <lcd_str_out+0x22>
        lcd_out(*(msg++));
    }
}
     e74:	0f 90       	pop	r0
     e76:	0f 90       	pop	r0
     e78:	cf 91       	pop	r28
     e7a:	df 91       	pop	r29
     e7c:	1f 91       	pop	r17
     e7e:	0f 91       	pop	r16
     e80:	ff 90       	pop	r15
     e82:	ef 90       	pop	r14
     e84:	08 95       	ret

00000e86 <lcd_line_clr>:

//---------------------------------------------------------
void lcd_line_clr(unsigned char line)
{
     e86:	1f 93       	push	r17
    unsigned char i;
    switch(line){
     e88:	82 30       	cpi	r24, 0x02	; 2
     e8a:	71 f0       	breq	.+28     	; 0xea8 <lcd_line_clr+0x22>
     e8c:	83 30       	cpi	r24, 0x03	; 3
     e8e:	b1 f0       	breq	.+44     	; 0xebc <lcd_line_clr+0x36>
     e90:	81 30       	cpi	r24, 0x01	; 1
     e92:	31 f5       	brne	.+76     	; 0xee0 <lcd_line_clr+0x5a>
     e94:	10 e0       	ldi	r17, 0x00	; 0
	case 1:
		for(i=0;i<LCD_SIZE;i++)
			lcd_char_out(1,i+1,' ');
     e96:	1f 5f       	subi	r17, 0xFF	; 255
     e98:	81 e0       	ldi	r24, 0x01	; 1
     e9a:	61 2f       	mov	r22, r17
     e9c:	40 e2       	ldi	r20, 0x20	; 32
     e9e:	0e 94 12 07 	call	0xe24	; 0xe24 <lcd_char_out>
void lcd_line_clr(unsigned char line)
{
    unsigned char i;
    switch(line){
	case 1:
		for(i=0;i<LCD_SIZE;i++)
     ea2:	18 30       	cpi	r17, 0x08	; 8
     ea4:	c1 f7       	brne	.-16     	; 0xe96 <lcd_line_clr+0x10>
     ea6:	1c c0       	rjmp	.+56     	; 0xee0 <lcd_line_clr+0x5a>

//---------------------------------------------------------
void lcd_line_clr(unsigned char line)
{
    unsigned char i;
    switch(line){
     ea8:	10 e0       	ldi	r17, 0x00	; 0
		for(i=0;i<LCD_SIZE;i++)
			lcd_char_out(1,i+1,' ');
		break;
	case 2:
		for(i=0;i<LCD_SIZE;i++)
			lcd_char_out(2,i+1,' ');
     eaa:	1f 5f       	subi	r17, 0xFF	; 255
     eac:	82 e0       	ldi	r24, 0x02	; 2
     eae:	61 2f       	mov	r22, r17
     eb0:	40 e2       	ldi	r20, 0x20	; 32
     eb2:	0e 94 12 07 	call	0xe24	; 0xe24 <lcd_char_out>
	case 1:
		for(i=0;i<LCD_SIZE;i++)
			lcd_char_out(1,i+1,' ');
		break;
	case 2:
		for(i=0;i<LCD_SIZE;i++)
     eb6:	18 30       	cpi	r17, 0x08	; 8
     eb8:	c1 f7       	brne	.-16     	; 0xeaa <lcd_line_clr+0x24>
     eba:	12 c0       	rjmp	.+36     	; 0xee0 <lcd_line_clr+0x5a>

//---------------------------------------------------------
void lcd_line_clr(unsigned char line)
{
    unsigned char i;
    switch(line){
     ebc:	10 e0       	ldi	r17, 0x00	; 0
		for(i=0;i<LCD_SIZE;i++)
			lcd_char_out(2,i+1,' ');
		break;
	case 3:
		for(i=0;i<LCD_SIZE;i++)
			lcd_char_out(1,i+1,' ');
     ebe:	1f 5f       	subi	r17, 0xFF	; 255
     ec0:	81 e0       	ldi	r24, 0x01	; 1
     ec2:	61 2f       	mov	r22, r17
     ec4:	40 e2       	ldi	r20, 0x20	; 32
     ec6:	0e 94 12 07 	call	0xe24	; 0xe24 <lcd_char_out>
	case 2:
		for(i=0;i<LCD_SIZE;i++)
			lcd_char_out(2,i+1,' ');
		break;
	case 3:
		for(i=0;i<LCD_SIZE;i++)
     eca:	18 30       	cpi	r17, 0x08	; 8
     ecc:	c1 f7       	brne	.-16     	; 0xebe <lcd_line_clr+0x38>
     ece:	10 e0       	ldi	r17, 0x00	; 0
			lcd_char_out(1,i+1,' ');
		for(i=0;i<LCD_SIZE;i++)
			lcd_char_out(2,i+1,' ');
     ed0:	1f 5f       	subi	r17, 0xFF	; 255
     ed2:	82 e0       	ldi	r24, 0x02	; 2
     ed4:	61 2f       	mov	r22, r17
     ed6:	40 e2       	ldi	r20, 0x20	; 32
     ed8:	0e 94 12 07 	call	0xe24	; 0xe24 <lcd_char_out>
			lcd_char_out(2,i+1,' ');
		break;
	case 3:
		for(i=0;i<LCD_SIZE;i++)
			lcd_char_out(1,i+1,' ');
		for(i=0;i<LCD_SIZE;i++)
     edc:	18 30       	cpi	r17, 0x08	; 8
     ede:	c1 f7       	brne	.-16     	; 0xed0 <lcd_line_clr+0x4a>
			lcd_char_out(2,i+1,' ');
		break;
    }
}
     ee0:	1f 91       	pop	r17
     ee2:	08 95       	ret

00000ee4 <lcd_shift>:

//---------------------------------------------------------
void lcd_shift(unsigned char RL)
{
    if(RL==LCD_RIGHT)
     ee4:	88 23       	and	r24, r24
     ee6:	11 f4       	brne	.+4      	; 0xeec <lcd_shift+0x8>
        command(LCD_R_SHF);
     ee8:	8c e1       	ldi	r24, 0x1C	; 28
     eea:	01 c0       	rjmp	.+2      	; 0xeee <lcd_shift+0xa>
    else
        command(LCD_L_SHF);
     eec:	88 e1       	ldi	r24, 0x18	; 24
     eee:	0e 94 ac 06 	call	0xd58	; 0xd58 <command>
     ef2:	08 95       	ret

00000ef4 <Beep>:
}

//buzzer
//////////////////////////////////////////////////////////////////////////////////////////////
void Beep(int position)
{
     ef4:	cf 93       	push	r28
     ef6:	df 93       	push	r29
	switch(position)
     ef8:	83 30       	cpi	r24, 0x03	; 3
     efa:	91 05       	cpc	r25, r1
     efc:	09 f4       	brne	.+2      	; 0xf00 <Beep+0xc>
     efe:	3e c0       	rjmp	.+124    	; 0xf7c <Beep+0x88>
     f00:	84 30       	cpi	r24, 0x04	; 4
     f02:	91 05       	cpc	r25, r1
     f04:	44 f4       	brge	.+16     	; 0xf16 <Beep+0x22>
     f06:	81 30       	cpi	r24, 0x01	; 1
     f08:	91 05       	cpc	r25, r1
     f0a:	71 f0       	breq	.+28     	; 0xf28 <Beep+0x34>
     f0c:	82 30       	cpi	r24, 0x02	; 2
     f0e:	91 05       	cpc	r25, r1
     f10:	09 f0       	breq	.+2      	; 0xf14 <Beep+0x20>
     f12:	82 c0       	rjmp	.+260    	; 0x1018 <Beep+0x124>
     f14:	1e c0       	rjmp	.+60     	; 0xf52 <Beep+0x5e>
     f16:	84 30       	cpi	r24, 0x04	; 4
     f18:	91 05       	cpc	r25, r1
     f1a:	09 f4       	brne	.+2      	; 0xf1e <Beep+0x2a>
     f1c:	44 c0       	rjmp	.+136    	; 0xfa6 <Beep+0xb2>
     f1e:	85 30       	cpi	r24, 0x05	; 5
     f20:	91 05       	cpc	r25, r1
     f22:	09 f0       	breq	.+2      	; 0xf26 <Beep+0x32>
     f24:	79 c0       	rjmp	.+242    	; 0x1018 <Beep+0x124>
     f26:	54 c0       	rjmp	.+168    	; 0xfd0 <Beep+0xdc>
	{
	case 1:
		sbi(DDRB,0);
     f28:	b8 9a       	sbi	0x17, 0	; 23
		sbi(DDRB,1);
     f2a:	b9 9a       	sbi	0x17, 1	; 23
		sbi(DDRB,2);
     f2c:	ba 9a       	sbi	0x17, 2	; 23
		sbi(DDRB,3);
     f2e:	bb 9a       	sbi	0x17, 3	; 23
     f30:	cc e2       	ldi	r28, 0x2C	; 44
     f32:	d1 e0       	ldi	r29, 0x01	; 1
				
		for(int i=0;i<300;i++){
			sbi(PORTB,1);	//buzzer ON
     f34:	c1 9a       	sbi	0x18, 1	; 24
			sbi(PORTB,0);	//LED ON			
     f36:	c0 9a       	sbi	0x18, 0	; 24
			delay(16);
     f38:	80 e1       	ldi	r24, 0x10	; 16
     f3a:	90 e0       	ldi	r25, 0x00	; 0
     f3c:	0e 94 74 06 	call	0xce8	; 0xce8 <delay>
				
			cbi(PORTB,1);	//buzzer OFF
     f40:	c1 98       	cbi	0x18, 1	; 24
			cbi(PORTB,0);	//LED OFF
     f42:	c0 98       	cbi	0x18, 0	; 24
			delay(16);
     f44:	80 e1       	ldi	r24, 0x10	; 16
     f46:	90 e0       	ldi	r25, 0x00	; 0
     f48:	0e 94 74 06 	call	0xce8	; 0xce8 <delay>
     f4c:	21 97       	sbiw	r28, 0x01	; 1
		sbi(DDRB,0);
		sbi(DDRB,1);
		sbi(DDRB,2);
		sbi(DDRB,3);
				
		for(int i=0;i<300;i++){
     f4e:	91 f7       	brne	.-28     	; 0xf34 <Beep+0x40>
     f50:	63 c0       	rjmp	.+198    	; 0x1018 <Beep+0x124>
		}	

		break;
		
	case 2:
		sbi(DDRD,0);
     f52:	88 9a       	sbi	0x11, 0	; 17
		sbi(DDRD,1);
     f54:	89 9a       	sbi	0x11, 1	; 17
		sbi(DDRD,2);
     f56:	8a 9a       	sbi	0x11, 2	; 17
		sbi(DDRD,3);
     f58:	8b 9a       	sbi	0x11, 3	; 17
     f5a:	cc e2       	ldi	r28, 0x2C	; 44
     f5c:	d1 e0       	ldi	r29, 0x01	; 1
		
		for(int i=0;i<300;i++){
			sbi(PORTD,1);	//buzzer ON
     f5e:	91 9a       	sbi	0x12, 1	; 18
			sbi(PORTD,0);	//LED ON
     f60:	90 9a       	sbi	0x12, 0	; 18
			delay(16);
     f62:	80 e1       	ldi	r24, 0x10	; 16
     f64:	90 e0       	ldi	r25, 0x00	; 0
     f66:	0e 94 74 06 	call	0xce8	; 0xce8 <delay>
			
			cbi(PORTD,1);	//buzzer OFF
     f6a:	91 98       	cbi	0x12, 1	; 18
			cbi(PORTD,0);	//LED OFF
     f6c:	90 98       	cbi	0x12, 0	; 18
			delay(16);
     f6e:	80 e1       	ldi	r24, 0x10	; 16
     f70:	90 e0       	ldi	r25, 0x00	; 0
     f72:	0e 94 74 06 	call	0xce8	; 0xce8 <delay>
     f76:	21 97       	sbiw	r28, 0x01	; 1
		sbi(DDRD,0);
		sbi(DDRD,1);
		sbi(DDRD,2);
		sbi(DDRD,3);
		
		for(int i=0;i<300;i++){
     f78:	91 f7       	brne	.-28     	; 0xf5e <Beep+0x6a>
     f7a:	4e c0       	rjmp	.+156    	; 0x1018 <Beep+0x124>
		}

		break;
		
	case 3:
		sbi(DDRD,4);
     f7c:	8c 9a       	sbi	0x11, 4	; 17
		sbi(DDRD,5);
     f7e:	8d 9a       	sbi	0x11, 5	; 17
		sbi(DDRD,6);
     f80:	8e 9a       	sbi	0x11, 6	; 17
		sbi(DDRD,7);
     f82:	8f 9a       	sbi	0x11, 7	; 17
     f84:	cc e2       	ldi	r28, 0x2C	; 44
     f86:	d1 e0       	ldi	r29, 0x01	; 1
		
		for(int i=0;i<300;i++){
			sbi(PORTD,5);	//buzzer ON
     f88:	95 9a       	sbi	0x12, 5	; 18
			sbi(PORTD,4);	//LED ON			
     f8a:	94 9a       	sbi	0x12, 4	; 18
			delay(16);
     f8c:	80 e1       	ldi	r24, 0x10	; 16
     f8e:	90 e0       	ldi	r25, 0x00	; 0
     f90:	0e 94 74 06 	call	0xce8	; 0xce8 <delay>

			cbi(PORTD,5);	//buzzer OFF
     f94:	95 98       	cbi	0x12, 5	; 18
			cbi(PORTD,4);	//LED OFF
     f96:	94 98       	cbi	0x12, 4	; 18
			delay(16);
     f98:	80 e1       	ldi	r24, 0x10	; 16
     f9a:	90 e0       	ldi	r25, 0x00	; 0
     f9c:	0e 94 74 06 	call	0xce8	; 0xce8 <delay>
     fa0:	21 97       	sbiw	r28, 0x01	; 1
		sbi(DDRD,4);
		sbi(DDRD,5);
		sbi(DDRD,6);
		sbi(DDRD,7);
		
		for(int i=0;i<300;i++){
     fa2:	91 f7       	brne	.-28     	; 0xf88 <Beep+0x94>
     fa4:	39 c0       	rjmp	.+114    	; 0x1018 <Beep+0x124>
		}

		break;
		
	case 4:	
		sbi(DDRE,0);
     fa6:	10 9a       	sbi	0x02, 0	; 2
		sbi(DDRE,1);
     fa8:	11 9a       	sbi	0x02, 1	; 2
		sbi(DDRE,2);
     faa:	12 9a       	sbi	0x02, 2	; 2
		sbi(DDRE,3);
     fac:	13 9a       	sbi	0x02, 3	; 2
     fae:	cc e2       	ldi	r28, 0x2C	; 44
     fb0:	d1 e0       	ldi	r29, 0x01	; 1

		for(int i=0;i<300;i++){
			sbi(PORTE,1);	//buzzer ON
     fb2:	19 9a       	sbi	0x03, 1	; 3
			sbi(PORTE,0);	//LED ON
     fb4:	18 9a       	sbi	0x03, 0	; 3
			delay(16);
     fb6:	80 e1       	ldi	r24, 0x10	; 16
     fb8:	90 e0       	ldi	r25, 0x00	; 0
     fba:	0e 94 74 06 	call	0xce8	; 0xce8 <delay>

			cbi(PORTE,1);	//buzzer OFF
     fbe:	19 98       	cbi	0x03, 1	; 3
			cbi(PORTE,0);	//LED OFF
     fc0:	18 98       	cbi	0x03, 0	; 3
			delay(16);
     fc2:	80 e1       	ldi	r24, 0x10	; 16
     fc4:	90 e0       	ldi	r25, 0x00	; 0
     fc6:	0e 94 74 06 	call	0xce8	; 0xce8 <delay>
     fca:	21 97       	sbiw	r28, 0x01	; 1
		sbi(DDRE,0);
		sbi(DDRE,1);
		sbi(DDRE,2);
		sbi(DDRE,3);

		for(int i=0;i<300;i++){
     fcc:	91 f7       	brne	.-28     	; 0xfb2 <Beep+0xbe>
     fce:	24 c0       	rjmp	.+72     	; 0x1018 <Beep+0x124>
		}

		break;
		
	case 5:
		sbi(DDRG,3);
     fd0:	80 91 64 00 	lds	r24, 0x0064
     fd4:	88 60       	ori	r24, 0x08	; 8
     fd6:	80 93 64 00 	sts	0x0064, r24
		cbi(PORTG,3);
     fda:	80 91 65 00 	lds	r24, 0x0065
     fde:	87 7f       	andi	r24, 0xF7	; 247
     fe0:	80 93 65 00 	sts	0x0065, r24
		sbi(DDRE,7);
     fe4:	17 9a       	sbi	0x02, 7	; 2
		cbi(PORTE,7);
     fe6:	1f 98       	cbi	0x03, 7	; 3
     fe8:	cc e2       	ldi	r28, 0x2C	; 44
     fea:	d1 e0       	ldi	r29, 0x01	; 1
		
		for(int i=0;i<300;i++){
			sbi(PORTG,3);	//buzzer ON
     fec:	80 91 65 00 	lds	r24, 0x0065
     ff0:	88 60       	ori	r24, 0x08	; 8
     ff2:	80 93 65 00 	sts	0x0065, r24
			sbi(PORTE,7);	//LED ON
     ff6:	1f 9a       	sbi	0x03, 7	; 3
			delay(16);
     ff8:	80 e1       	ldi	r24, 0x10	; 16
     ffa:	90 e0       	ldi	r25, 0x00	; 0
     ffc:	0e 94 74 06 	call	0xce8	; 0xce8 <delay>
	
			cbi(PORTG,3);	//buzzer OFF
    1000:	80 91 65 00 	lds	r24, 0x0065
    1004:	87 7f       	andi	r24, 0xF7	; 247
    1006:	80 93 65 00 	sts	0x0065, r24
			cbi(PORTE,7);	//LED OFF
    100a:	1f 98       	cbi	0x03, 7	; 3
			delay(16);
    100c:	80 e1       	ldi	r24, 0x10	; 16
    100e:	90 e0       	ldi	r25, 0x00	; 0
    1010:	0e 94 74 06 	call	0xce8	; 0xce8 <delay>
    1014:	21 97       	sbiw	r28, 0x01	; 1
		sbi(DDRG,3);
		cbi(PORTG,3);
		sbi(DDRE,7);
		cbi(PORTE,7);
		
		for(int i=0;i<300;i++){
    1016:	51 f7       	brne	.-44     	; 0xfec <Beep+0xf8>
	default:
		break;
	
	}
	
}
    1018:	df 91       	pop	r29
    101a:	cf 91       	pop	r28
    101c:	08 95       	ret

0000101e <InitADC>:


void InitADC(void)
{
	
    outp(BV(ADIF)|BV(ADEN)|BV(ADIE)|BV(ADPS0),ADCSRA);     
    101e:	89 e9       	ldi	r24, 0x99	; 153
    1020:	86 b9       	out	0x06, r24	; 6
    outp(0,ADMUX);      //default channel 선택	
    1022:	17 b8       	out	0x07, r1	; 7
    ADCComplete = 1;	
    1024:	81 e0       	ldi	r24, 0x01	; 1
    1026:	80 93 99 01 	sts	0x0199, r24
}
    102a:	08 95       	ret

0000102c <GetADC>:
//---------------------------------------------------------
//Get Analog to Digital Converter
u08 GetADC()
{
	u08 temp;
    while(!ADCComplete); 	
    102c:	80 91 99 01 	lds	r24, 0x0199
    1030:	88 23       	and	r24, r24
    1032:	e1 f3       	breq	.-8      	; 0x102c <GetADC>
    ADCComplete = 0;
    1034:	10 92 99 01 	sts	0x0199, r1
    
    temp = inp(ADCSRA);		
    outp(temp|0x40,ADCSRA);	
    1038:	36 9a       	sbi	0x06, 6	; 6

    while(!ADCComplete); 
    103a:	80 91 99 01 	lds	r24, 0x0199
    103e:	88 23       	and	r24, r24
    1040:	e1 f3       	breq	.-8      	; 0x103a <GetADC+0xe>
	
	temp = ((u08)(ADCData[0]>>2)) | ((u08)(ADCData[1]<<6));
    1042:	90 91 e6 01 	lds	r25, 0x01E6
    1046:	92 95       	swap	r25
    1048:	99 0f       	add	r25, r25
    104a:	99 0f       	add	r25, r25
    104c:	90 7c       	andi	r25, 0xC0	; 192
    104e:	80 91 e5 01 	lds	r24, 0x01E5
    1052:	86 95       	lsr	r24
    1054:	86 95       	lsr	r24
    return temp;
}
    1056:	89 2b       	or	r24, r25
    1058:	08 95       	ret

0000105a <GetCds>:
//---------------------------------------------------------
u08 GetCds(int pos)
{
    u08 tempCds;
   
	switch(pos){
    105a:	83 30       	cpi	r24, 0x03	; 3
    105c:	91 05       	cpc	r25, r1
    105e:	a9 f0       	breq	.+42     	; 0x108a <GetCds+0x30>
    1060:	84 30       	cpi	r24, 0x04	; 4
    1062:	91 05       	cpc	r25, r1
    1064:	3c f4       	brge	.+14     	; 0x1074 <GetCds+0x1a>
    1066:	81 30       	cpi	r24, 0x01	; 1
    1068:	91 05       	cpc	r25, r1
    106a:	59 f0       	breq	.+22     	; 0x1082 <GetCds+0x28>
    106c:	82 30       	cpi	r24, 0x02	; 2
    106e:	91 05       	cpc	r25, r1
    1070:	91 f4       	brne	.+36     	; 0x1096 <GetCds+0x3c>
    1072:	09 c0       	rjmp	.+18     	; 0x1086 <GetCds+0x2c>
    1074:	84 30       	cpi	r24, 0x04	; 4
    1076:	91 05       	cpc	r25, r1
    1078:	51 f0       	breq	.+20     	; 0x108e <GetCds+0x34>
    107a:	85 30       	cpi	r24, 0x05	; 5
    107c:	91 05       	cpc	r25, r1
    107e:	59 f4       	brne	.+22     	; 0x1096 <GetCds+0x3c>
    1080:	08 c0       	rjmp	.+16     	; 0x1092 <GetCds+0x38>
		case 1:
			ADC_CHANNEL(AD_0);				// Cds value => ADC
    1082:	17 b8       	out	0x07, r1	; 7
			break;
    1084:	08 c0       	rjmp	.+16     	; 0x1096 <GetCds+0x3c>
		case 2:
			ADC_CHANNEL(AD_1);				// Cds value => ADC 
    1086:	81 e0       	ldi	r24, 0x01	; 1
    1088:	05 c0       	rjmp	.+10     	; 0x1094 <GetCds+0x3a>
			break;
		case 3:
			ADC_CHANNEL(AD_2);				// Cds value => ADC
    108a:	82 e0       	ldi	r24, 0x02	; 2
    108c:	03 c0       	rjmp	.+6      	; 0x1094 <GetCds+0x3a>
			break;
		case 4:
			ADC_CHANNEL(AD_3);				// Cds value => ADC
    108e:	83 e0       	ldi	r24, 0x03	; 3
    1090:	01 c0       	rjmp	.+2      	; 0x1094 <GetCds+0x3a>
			break;
		
		case 5:
			ADC_CHANNEL(AD_4);				// Cds value => ADC
    1092:	84 e0       	ldi	r24, 0x04	; 4
    1094:	87 b9       	out	0x07, r24	; 7
		
		default:
			break;	
	}
		
	tempCds = GetADC();				// AD start
    1096:	0e 94 16 08 	call	0x102c	; 0x102c <GetADC>

	if(tempCds < 20){								//2007.06.27 수정
    109a:	84 31       	cpi	r24, 0x14	; 20
    109c:	50 f0       	brcs	.+20     	; 0x10b2 <GetCds+0x58>
	    return 0;   //Cds Sensor Read Failed
	}else if(tempCds <= ILLUMINANCE_LV1){
    109e:	8f 31       	cpi	r24, 0x1F	; 31
    10a0:	50 f0       	brcs	.+20     	; 0x10b6 <GetCds+0x5c>
	    return 1;   
	}else if(tempCds <= ILLUMINANCE_LV2){
    10a2:	81 35       	cpi	r24, 0x51	; 81
    10a4:	50 f0       	brcs	.+20     	; 0x10ba <GetCds+0x60>
	    return 2;   
	}else if(tempCds <= ILLUMINANCE_LV3){
    10a6:	89 37       	cpi	r24, 0x79	; 121
    10a8:	50 f0       	brcs	.+20     	; 0x10be <GetCds+0x64>
	    return 3;
	}else if(tempCds <= ILLUMINANCE_LV4){
    10aa:	87 39       	cpi	r24, 0x97	; 151
    10ac:	50 f4       	brcc	.+20     	; 0x10c2 <GetCds+0x68>
	    return 4;   
    10ae:	84 e0       	ldi	r24, 0x04	; 4
    10b0:	08 95       	ret
	}
		
	tempCds = GetADC();				// AD start

	if(tempCds < 20){								//2007.06.27 수정
	    return 0;   //Cds Sensor Read Failed
    10b2:	80 e0       	ldi	r24, 0x00	; 0
    10b4:	08 95       	ret
	}else if(tempCds <= ILLUMINANCE_LV1){
	    return 1;   
    10b6:	81 e0       	ldi	r24, 0x01	; 1
    10b8:	08 95       	ret
	}else if(tempCds <= ILLUMINANCE_LV2){
	    return 2;   
    10ba:	82 e0       	ldi	r24, 0x02	; 2
    10bc:	08 95       	ret
	}else if(tempCds <= ILLUMINANCE_LV3){
	    return 3;
    10be:	83 e0       	ldi	r24, 0x03	; 3
    10c0:	08 95       	ret
	}else if(tempCds <= ILLUMINANCE_LV4){
	    return 4;   
	}else{
		return 5;					//2007.06.27 수정
    10c2:	85 e0       	ldi	r24, 0x05	; 5
	}
}
    10c4:	08 95       	ret

000010c6 <Initialize>:
}

//초기화 루틴
/////////////////////////////////////////////////////////////////////////////////////////////////
void Initialize()
{	
    10c6:	cf 93       	push	r28
    10c8:	df 93       	push	r29
	
	fMicSample = 0;
    10ca:	10 92 6a 01 	sts	0x016A, r1
	fcdsSample = 0;
    10ce:	10 92 bb 01 	sts	0x01BB, r1
	
	
	outp(0x40, DDRC);
    10d2:	80 e4       	ldi	r24, 0x40	; 64
    10d4:	84 bb       	out	0x14, r24	; 20
	outp(0xff, PORTC);
    10d6:	8f ef       	ldi	r24, 0xFF	; 255
    10d8:	85 bb       	out	0x15, r24	; 21
	
	
	outp(0x00, TCNT0);
    10da:	12 be       	out	0x32, r1	; 50
	outp(0x01, TCCR0);  		
    10dc:	81 e0       	ldi	r24, 0x01	; 1
    10de:	83 bf       	out	0x33, r24	; 51
	outp(BV(TOIE0), TIMSK);		
    10e0:	87 bf       	out	0x37, r24	; 55
	
	sei();
    10e2:	78 94       	sei
	
	// LCD Initialize
    lcd_port_init();
    10e4:	0e 94 a4 06 	call	0xd48	; 0xd48 <lcd_port_init>
    lcd_init();
    10e8:	0e 94 ca 06 	call	0xd94	; 0xd94 <lcd_init>
	
		command(i | 0x40);	
		lcd_out(degree[i]);					
	}
*/	
	outp(DDRF_INPUT,DDRF);	
    10ec:	10 92 61 00 	sts	0x0061, r1
	InitADC();				
    10f0:	0e 94 0f 08 	call	0x101e	; 0x101e <InitADC>
	
	//lcd Initialize	
	lcd_str_out(1,1,empty);
    10f4:	c3 e3       	ldi	r28, 0x33	; 51
    10f6:	d1 e0       	ldi	r29, 0x01	; 1
    10f8:	81 e0       	ldi	r24, 0x01	; 1
    10fa:	61 e0       	ldi	r22, 0x01	; 1
    10fc:	ae 01       	movw	r20, r28
    10fe:	0e 94 22 07 	call	0xe44	; 0xe44 <lcd_str_out>
	lcd_str_out(2,1,empty);
    1102:	82 e0       	ldi	r24, 0x02	; 2
    1104:	61 e0       	ldi	r22, 0x01	; 1
    1106:	ae 01       	movw	r20, r28
    1108:	0e 94 22 07 	call	0xe44	; 0xe44 <lcd_str_out>
	
    delay(100);
    110c:	84 e6       	ldi	r24, 0x64	; 100
    110e:	90 e0       	ldi	r25, 0x00	; 0
    1110:	0e 94 74 06 	call	0xce8	; 0xce8 <delay>
    
}
    1114:	df 91       	pop	r29
    1116:	cf 91       	pop	r28
    1118:	08 95       	ret

0000111a <GetCdsVal>:


//---------------------------------------------------------
bool GetCdsVal(u08 pos,u08 val)
{
    111a:	df 93       	push	r29
    111c:	cf 93       	push	r28
    111e:	0f 92       	push	r0
    1120:	cd b7       	in	r28, 0x3d	; 61
    1122:	de b7       	in	r29, 0x3e	; 62
	
	if(GetCds(pos) >= val){
    1124:	90 e0       	ldi	r25, 0x00	; 0
    1126:	69 83       	std	Y+1, r22	; 0x01
    1128:	0e 94 2d 08 	call	0x105a	; 0x105a <GetCds>
		return TRUE;
    112c:	91 e0       	ldi	r25, 0x01	; 1
    112e:	69 81       	ldd	r22, Y+1	; 0x01
    1130:	86 17       	cp	r24, r22
    1132:	08 f4       	brcc	.+2      	; 0x1136 <GetCdsVal+0x1c>
    1134:	90 e0       	ldi	r25, 0x00	; 0
	}else{
		return FALSE;
	}
	
}
    1136:	89 2f       	mov	r24, r25
    1138:	0f 90       	pop	r0
    113a:	cf 91       	pop	r28
    113c:	df 91       	pop	r29
    113e:	08 95       	ret

00001140 <GetRemoconVal>:


//---------------------------------------------------------
bool GetRemoconVal(u08 repos,u08 nVal)
{
    1140:	1f 93       	push	r17
    1142:	16 2f       	mov	r17, r22
	
	u08 temp = 0;
	REPosition(repos);
    1144:	0e 94 34 01 	call	0x268	; 0x268 <REPosition>

	if(IRReg&IrRxdFLAG){			
    1148:	80 91 0d 01 	lds	r24, 0x010D
    114c:	87 ff       	sbrs	r24, 7
    114e:	07 c0       	rjmp	.+14     	; 0x115e <GetRemoconVal+0x1e>
		temp = GetRemocon();        	
    1150:	0e 94 eb 03 	call	0x7d6	; 0x7d6 <GetRemocon>
    1154:	98 2f       	mov	r25, r24
		RemoconValuedelayCnt = 3; 				       
    1156:	83 e0       	ldi	r24, 0x03	; 3
    1158:	80 93 47 01 	sts	0x0147, r24
    115c:	01 c0       	rjmp	.+2      	; 0x1160 <GetRemoconVal+0x20>

//---------------------------------------------------------
bool GetRemoconVal(u08 repos,u08 nVal)
{
	
	u08 temp = 0;
    115e:	90 e0       	ldi	r25, 0x00	; 0
		temp = GetRemocon();        	
		RemoconValuedelayCnt = 3; 				       
      }

	if(temp == nVal){
		return TRUE;
    1160:	81 e0       	ldi	r24, 0x01	; 1
    1162:	91 13       	cpse	r25, r17
    1164:	80 e0       	ldi	r24, 0x00	; 0
	}else{
		return FALSE;
	}
	   
}
    1166:	1f 91       	pop	r17
    1168:	08 95       	ret

0000116a <GetMicVal>:


//---------------------------------------------------------
bool GetMicVal(u08 nLevel)
{
    116a:	1f 93       	push	r17
    116c:	18 2f       	mov	r17, r24
	
	u08 tempMic;
	
	if(fMicSample){
    116e:	80 91 6a 01 	lds	r24, 0x016A
    1172:	88 23       	and	r24, r24
    1174:	39 f0       	breq	.+14     	; 0x1184 <GetMicVal+0x1a>
	ADC_CHANNEL(MIC_IN);		
    1176:	86 e0       	ldi	r24, 0x06	; 6
    1178:	87 b9       	out	0x07, r24	; 7
	tempMic = GetADC();			// AD start	
    117a:	0e 94 16 08 	call	0x102c	; 0x102c <GetADC>
    117e:	98 2f       	mov	r25, r24
	fMicSample = 0;	 	        
    1180:	10 92 6a 01 	sts	0x016A, r1
    }

	if(tempMic >= nLevel)    
		return TRUE;
    1184:	81 e0       	ldi	r24, 0x01	; 1
    1186:	91 17       	cp	r25, r17
    1188:	08 f4       	brcc	.+2      	; 0x118c <GetMicVal+0x22>
    118a:	80 e0       	ldi	r24, 0x00	; 0
	else
		return FALSE;

}
    118c:	1f 91       	pop	r17
    118e:	08 95       	ret

00001190 <GetPhotoSensor>:

//---------------------------------------------------------
bool GetPhotoSensor(u08 sel,u08 nPhotoVal)
{
	
	ControlPortc = 1;
    1190:	91 e0       	ldi	r25, 0x01	; 1
    1192:	90 93 3e 01 	sts	0x013E, r25
	SensorDir = sel;
    1196:	80 93 60 01 	sts	0x0160, r24

	if(sel == FORWARD){
    119a:	81 30       	cpi	r24, 0x01	; 1
    119c:	31 f4       	brne	.+12     	; 0x11aa <GetPhotoSensor+0x1a>
		
		if(ForwardPhotoSensor == nPhotoVal){
			return TRUE;
    119e:	90 91 78 01 	lds	r25, 0x0178
    11a2:	96 17       	cp	r25, r22
    11a4:	39 f0       	breq	.+14     	; 0x11b4 <GetPhotoSensor+0x24>
    11a6:	80 e0       	ldi	r24, 0x00	; 0
    11a8:	08 95       	ret
    11aa:	81 e0       	ldi	r24, 0x01	; 1
    11ac:	90 91 55 01 	lds	r25, 0x0155
    11b0:	96 13       	cpse	r25, r22
    11b2:	80 e0       	ldi	r24, 0x00	; 0
			return FALSE;		
		}		

	}

}
    11b4:	08 95       	ret

000011b6 <TactSWModuleCtrl>:


//---------------------------------------------------------
bool TactSWModuleCtrl(u08 pos,u08 val)
{
    11b6:	1f 93       	push	r17
    11b8:	16 2f       	mov	r17, r22

	static u08 swvalue = 0;
	static u08 Nswvalue = 0;
	u08 SwState = 0;

	outp(0x00,SFIOR);		
    11ba:	10 bc       	out	0x20, r1	; 32

	
	switch(pos)
    11bc:	83 30       	cpi	r24, 0x03	; 3
    11be:	91 f1       	breq	.+100    	; 0x1224 <TactSWModuleCtrl+0x6e>
    11c0:	84 30       	cpi	r24, 0x04	; 4
    11c2:	30 f4       	brcc	.+12     	; 0x11d0 <TactSWModuleCtrl+0x1a>
    11c4:	81 30       	cpi	r24, 0x01	; 1
    11c6:	51 f0       	breq	.+20     	; 0x11dc <TactSWModuleCtrl+0x26>
    11c8:	82 30       	cpi	r24, 0x02	; 2
    11ca:	09 f0       	breq	.+2      	; 0x11ce <TactSWModuleCtrl+0x18>
    11cc:	88 c0       	rjmp	.+272    	; 0x12de <TactSWModuleCtrl+0x128>
    11ce:	18 c0       	rjmp	.+48     	; 0x1200 <TactSWModuleCtrl+0x4a>
    11d0:	84 30       	cpi	r24, 0x04	; 4
    11d2:	e1 f1       	breq	.+120    	; 0x124c <TactSWModuleCtrl+0x96>
    11d4:	85 30       	cpi	r24, 0x05	; 5
    11d6:	09 f0       	breq	.+2      	; 0x11da <TactSWModuleCtrl+0x24>
    11d8:	82 c0       	rjmp	.+260    	; 0x12de <TactSWModuleCtrl+0x128>
    11da:	4c c0       	rjmp	.+152    	; 0x1274 <TactSWModuleCtrl+0xbe>
	{
		case 1:
			cbi(DDRB , 0);	cbi(DDRB , 1);	cbi(DDRB , 2);	
    11dc:	b8 98       	cbi	0x17, 0	; 23
    11de:	b9 98       	cbi	0x17, 1	; 23
    11e0:	ba 98       	cbi	0x17, 2	; 23
			sbi(PORTB, 0);	sbi(PORTB, 1);	sbi(PORTB, 2);	
    11e2:	c0 9a       	sbi	0x18, 0	; 24
    11e4:	c1 9a       	sbi	0x18, 1	; 24
    11e6:	c2 9a       	sbi	0x18, 2	; 24
			delayms(1);
    11e8:	81 e0       	ldi	r24, 0x01	; 1
    11ea:	90 e0       	ldi	r25, 0x00	; 0
    11ec:	0e 94 55 06 	call	0xcaa	; 0xcaa <delayms>
			
			if((0x01&inp(PINB)) == 0){				        
    11f0:	86 b3       	in	r24, 0x16	; 22
    11f2:	80 ff       	sbrs	r24, 0
    11f4:	5b c0       	rjmp	.+182    	; 0x12ac <TactSWModuleCtrl+0xf6>
				swvalue = 0xfe;								
			}else if((0x02&inp(PINB)) == 0){
    11f6:	86 b3       	in	r24, 0x16	; 22
    11f8:	81 ff       	sbrs	r24, 1
    11fa:	5e c0       	rjmp	.+188    	; 0x12b8 <TactSWModuleCtrl+0x102>
				swvalue = 0xfd;									
			}else if((0x04&inp(PINB)) == 0){
    11fc:	86 b3       	in	r24, 0x16	; 22
    11fe:	37 c0       	rjmp	.+110    	; 0x126e <TactSWModuleCtrl+0xb8>
				swvalue = 0xff;						
			} 
			break;

		case 2:
			cbi(DDRD ,0 );	cbi(DDRD ,1 );	cbi(DDRD ,2 );	
    1200:	88 98       	cbi	0x11, 0	; 17
    1202:	89 98       	cbi	0x11, 1	; 17
    1204:	8a 98       	cbi	0x11, 2	; 17
			sbi(PORTD,0 );	sbi(PORTD,1 );	sbi(PORTD,2 );	
    1206:	90 9a       	sbi	0x12, 0	; 18
    1208:	91 9a       	sbi	0x12, 1	; 18
    120a:	92 9a       	sbi	0x12, 2	; 18
			delayms(1);
    120c:	81 e0       	ldi	r24, 0x01	; 1
    120e:	90 e0       	ldi	r25, 0x00	; 0
    1210:	0e 94 55 06 	call	0xcaa	; 0xcaa <delayms>

			if((0x01&inp(PIND)) == 0){				
    1214:	80 b3       	in	r24, 0x10	; 16
    1216:	80 ff       	sbrs	r24, 0
    1218:	49 c0       	rjmp	.+146    	; 0x12ac <TactSWModuleCtrl+0xf6>
				swvalue = 0xfe;								
			}else if((0x02&inp(PIND)) == 0){
    121a:	80 b3       	in	r24, 0x10	; 16
    121c:	81 ff       	sbrs	r24, 1
    121e:	4c c0       	rjmp	.+152    	; 0x12b8 <TactSWModuleCtrl+0x102>
				swvalue = 0xfd;								
			}else if((0x04&inp(PIND)) == 0){
    1220:	80 b3       	in	r24, 0x10	; 16
    1222:	25 c0       	rjmp	.+74     	; 0x126e <TactSWModuleCtrl+0xb8>
				swvalue = 0xff;						
			}
			break;

		case 3:
			cbi(DDRD, 4);	cbi(DDRD ,5);	cbi(DDRD ,6);	
    1224:	8c 98       	cbi	0x11, 4	; 17
    1226:	8d 98       	cbi	0x11, 5	; 17
    1228:	8e 98       	cbi	0x11, 6	; 17
			sbi(PORTD,4);	sbi(PORTD,5);	sbi(PORTD,6);	
    122a:	94 9a       	sbi	0x12, 4	; 18
    122c:	95 9a       	sbi	0x12, 5	; 18
    122e:	96 9a       	sbi	0x12, 6	; 18
			delayms(1);
    1230:	81 e0       	ldi	r24, 0x01	; 1
    1232:	90 e0       	ldi	r25, 0x00	; 0
    1234:	0e 94 55 06 	call	0xcaa	; 0xcaa <delayms>
		
			if((0x10&inp(PIND)) == 0){				
    1238:	80 b3       	in	r24, 0x10	; 16
    123a:	84 ff       	sbrs	r24, 4
    123c:	37 c0       	rjmp	.+110    	; 0x12ac <TactSWModuleCtrl+0xf6>
				swvalue = 0xfe;						
			}else if((0x20&inp(PIND)) == 0){
    123e:	80 b3       	in	r24, 0x10	; 16
    1240:	85 ff       	sbrs	r24, 5
    1242:	3a c0       	rjmp	.+116    	; 0x12b8 <TactSWModuleCtrl+0x102>
				swvalue = 0xfd;						
			}else if((0x40&inp(PIND)) == 0){
    1244:	80 b3       	in	r24, 0x10	; 16
    1246:	86 fd       	sbrc	r24, 6
    1248:	3f c0       	rjmp	.+126    	; 0x12c8 <TactSWModuleCtrl+0x112>
    124a:	3c c0       	rjmp	.+120    	; 0x12c4 <TactSWModuleCtrl+0x10e>
				swvalue = 0xff;						
			}
			break;

		case 4:
			cbi(DDRE , 0);	cbi(DDRE , 1);	cbi(DDRE , 2);	
    124c:	10 98       	cbi	0x02, 0	; 2
    124e:	11 98       	cbi	0x02, 1	; 2
    1250:	12 98       	cbi	0x02, 2	; 2
			sbi(PORTE, 0);	sbi(PORTE, 1);	sbi(PORTE, 2);	
    1252:	18 9a       	sbi	0x03, 0	; 3
    1254:	19 9a       	sbi	0x03, 1	; 3
    1256:	1a 9a       	sbi	0x03, 2	; 3
			delayms(1);
    1258:	81 e0       	ldi	r24, 0x01	; 1
    125a:	90 e0       	ldi	r25, 0x00	; 0
    125c:	0e 94 55 06 	call	0xcaa	; 0xcaa <delayms>

			if((0x01&inp(PINE)) == 0){				
    1260:	81 b1       	in	r24, 0x01	; 1
    1262:	80 ff       	sbrs	r24, 0
    1264:	23 c0       	rjmp	.+70     	; 0x12ac <TactSWModuleCtrl+0xf6>
				swvalue = 0xfe;						
			}else if((0x02&inp(PINE)) == 0){
    1266:	81 b1       	in	r24, 0x01	; 1
    1268:	81 ff       	sbrs	r24, 1
    126a:	26 c0       	rjmp	.+76     	; 0x12b8 <TactSWModuleCtrl+0x102>
				swvalue = 0xfd;						
			}else if((0x04&inp(PINE)) == 0){
    126c:	81 b1       	in	r24, 0x01	; 1
    126e:	82 fd       	sbrc	r24, 2
    1270:	2b c0       	rjmp	.+86     	; 0x12c8 <TactSWModuleCtrl+0x112>
    1272:	28 c0       	rjmp	.+80     	; 0x12c4 <TactSWModuleCtrl+0x10e>
				swvalue = 0xff;						
			}
			break;

		case 5:
			cbi(DDRE ,7 );	cbi(DDRG ,3 );	cbi(DDRG ,4 );	
    1274:	17 98       	cbi	0x02, 7	; 2
    1276:	80 91 64 00 	lds	r24, 0x0064
    127a:	87 7f       	andi	r24, 0xF7	; 247
    127c:	80 93 64 00 	sts	0x0064, r24
    1280:	80 91 64 00 	lds	r24, 0x0064
    1284:	8f 7e       	andi	r24, 0xEF	; 239
    1286:	80 93 64 00 	sts	0x0064, r24
			sbi(PORTE,7 );  sbi(PORTG,3 );	sbi(PORTG,4 );	
    128a:	1f 9a       	sbi	0x03, 7	; 3
    128c:	80 91 65 00 	lds	r24, 0x0065
    1290:	88 60       	ori	r24, 0x08	; 8
    1292:	80 93 65 00 	sts	0x0065, r24
    1296:	80 91 65 00 	lds	r24, 0x0065
    129a:	80 61       	ori	r24, 0x10	; 16
    129c:	80 93 65 00 	sts	0x0065, r24
			delayms(1);
    12a0:	81 e0       	ldi	r24, 0x01	; 1
    12a2:	90 e0       	ldi	r25, 0x00	; 0
    12a4:	0e 94 55 06 	call	0xcaa	; 0xcaa <delayms>
			
			if((0x80&inp(PINE)) == 0){
    12a8:	0f 99       	sbic	0x01, 7	; 1
    12aa:	02 c0       	rjmp	.+4      	; 0x12b0 <TactSWModuleCtrl+0xfa>
				swvalue = 0xfe;						
    12ac:	8e ef       	ldi	r24, 0xFE	; 254
    12ae:	0d c0       	rjmp	.+26     	; 0x12ca <TactSWModuleCtrl+0x114>
			}else if((0x08&inp(PING)) == 0){
    12b0:	80 91 63 00 	lds	r24, 0x0063
    12b4:	83 fd       	sbrc	r24, 3
    12b6:	02 c0       	rjmp	.+4      	; 0x12bc <TactSWModuleCtrl+0x106>
				swvalue = 0xfd;						
    12b8:	8d ef       	ldi	r24, 0xFD	; 253
    12ba:	07 c0       	rjmp	.+14     	; 0x12ca <TactSWModuleCtrl+0x114>
			}else if((0x10&inp(PING)) == 0){
    12bc:	80 91 63 00 	lds	r24, 0x0063
    12c0:	84 fd       	sbrc	r24, 4
    12c2:	02 c0       	rjmp	.+4      	; 0x12c8 <TactSWModuleCtrl+0x112>
				swvalue = 0xfb;						
    12c4:	8b ef       	ldi	r24, 0xFB	; 251
    12c6:	01 c0       	rjmp	.+2      	; 0x12ca <TactSWModuleCtrl+0x114>
			}else{
				swvalue = 0xff;						
    12c8:	8f ef       	ldi	r24, 0xFF	; 255
    12ca:	80 93 4a 01 	sts	0x014A, r24
		default:
			return 0x00;

	}

    swvalue = (0x07& (~swvalue));	
    12ce:	90 91 4a 01 	lds	r25, 0x014A
    12d2:	90 95       	com	r25
    12d4:	97 70       	andi	r25, 0x07	; 7
    12d6:	90 93 4a 01 	sts	0x014A, r25
				swvalue = 0xff;						
			}   
			break;

		default:
			return 0x00;
    12da:	81 e0       	ldi	r24, 0x01	; 1
    12dc:	91 13       	cpse	r25, r17
    12de:	80 e0       	ldi	r24, 0x00	; 0
		return TRUE;
	}else{
		return FALSE;
	}

}
    12e0:	1f 91       	pop	r17
    12e2:	08 95       	ret

000012e4 <TouchSensor>:
bool TouchSensor(u08 pos)
{

	u08 temp = 0;	

	switch(pos)
    12e4:	83 30       	cpi	r24, 0x03	; 3
    12e6:	21 f1       	breq	.+72     	; 0x1330 <TouchSensor+0x4c>
    12e8:	84 30       	cpi	r24, 0x04	; 4
    12ea:	30 f4       	brcc	.+12     	; 0x12f8 <TouchSensor+0x14>
    12ec:	81 30       	cpi	r24, 0x01	; 1
    12ee:	51 f0       	breq	.+20     	; 0x1304 <TouchSensor+0x20>
    12f0:	82 30       	cpi	r24, 0x02	; 2
    12f2:	09 f0       	breq	.+2      	; 0x12f6 <TouchSensor+0x12>
    12f4:	55 c0       	rjmp	.+170    	; 0x13a0 <TouchSensor+0xbc>
    12f6:	11 c0       	rjmp	.+34     	; 0x131a <TouchSensor+0x36>
    12f8:	84 30       	cpi	r24, 0x04	; 4
    12fa:	29 f1       	breq	.+74     	; 0x1346 <TouchSensor+0x62>
    12fc:	85 30       	cpi	r24, 0x05	; 5
    12fe:	09 f0       	breq	.+2      	; 0x1302 <TouchSensor+0x1e>
    1300:	4f c0       	rjmp	.+158    	; 0x13a0 <TouchSensor+0xbc>
    1302:	2c c0       	rjmp	.+88     	; 0x135c <TouchSensor+0x78>
	{
		case 1:
			cbi(DDRB,0);	cbi(PORTB,0);		
    1304:	b8 98       	cbi	0x17, 0	; 23
    1306:	c0 98       	cbi	0x18, 0	; 24
			sbi(DDRB,3);	sbi(PORTB,3);
    1308:	bb 9a       	sbi	0x17, 3	; 23
    130a:	c3 9a       	sbi	0x18, 3	; 24
		
			temp = (0x01 & inp(PINB));
    130c:	86 b3       	in	r24, 0x16	; 22
		
			if(temp == 0x01)
    130e:	80 ff       	sbrs	r24, 0
    1310:	02 c0       	rjmp	.+4      	; 0x1316 <TouchSensor+0x32>
			{
				cbi(PORTB,3);						
    1312:	c3 98       	cbi	0x18, 3	; 24
    1314:	38 c0       	rjmp	.+112    	; 0x1386 <TouchSensor+0xa2>
				delayms(1);	
				return TRUE;
			}
	
			sbi(PORTB,3);
    1316:	c3 9a       	sbi	0x18, 3	; 24
    1318:	41 c0       	rjmp	.+130    	; 0x139c <TouchSensor+0xb8>
			return FALSE;
			break;

		case 2:
			cbi(DDRD,0);	cbi(PORTD,0);		
    131a:	88 98       	cbi	0x11, 0	; 17
    131c:	90 98       	cbi	0x12, 0	; 18
			sbi(DDRD,3);	sbi(PORTD,3);
    131e:	8b 9a       	sbi	0x11, 3	; 17
    1320:	93 9a       	sbi	0x12, 3	; 18
	
			temp = (0x01 & inp(PIND));
    1322:	80 b3       	in	r24, 0x10	; 16
			
			if(temp == 0x01)
    1324:	80 ff       	sbrs	r24, 0
    1326:	02 c0       	rjmp	.+4      	; 0x132c <TouchSensor+0x48>
			{
				cbi(PORTD,3);						
    1328:	93 98       	cbi	0x12, 3	; 18
    132a:	2d c0       	rjmp	.+90     	; 0x1386 <TouchSensor+0xa2>
				delayms(1);	
				return TRUE;
			}

			sbi(PORTD,3);
    132c:	93 9a       	sbi	0x12, 3	; 18
    132e:	36 c0       	rjmp	.+108    	; 0x139c <TouchSensor+0xb8>
			return FALSE;
			break;

		case 3:
			cbi(DDRD,4);	cbi(PORTD,4);		
    1330:	8c 98       	cbi	0x11, 4	; 17
    1332:	94 98       	cbi	0x12, 4	; 18
			sbi(DDRD,7);	sbi(PORTD,7);
    1334:	8f 9a       	sbi	0x11, 7	; 17
    1336:	97 9a       	sbi	0x12, 7	; 18

			temp = (0x10 & inp(PIND));
    1338:	80 b3       	in	r24, 0x10	; 16

			if(temp == 0x10)
    133a:	84 ff       	sbrs	r24, 4
    133c:	02 c0       	rjmp	.+4      	; 0x1342 <TouchSensor+0x5e>
			{
				cbi(PORTD,7);						
    133e:	97 98       	cbi	0x12, 7	; 18
    1340:	22 c0       	rjmp	.+68     	; 0x1386 <TouchSensor+0xa2>
				delayms(1);	
				return TRUE;
			}

			sbi(PORTD,7);
    1342:	97 9a       	sbi	0x12, 7	; 18
    1344:	2b c0       	rjmp	.+86     	; 0x139c <TouchSensor+0xb8>
			return FALSE;
			break;

		case 4:
			cbi(DDRE,0);	cbi(PORTE,0);		
    1346:	10 98       	cbi	0x02, 0	; 2
    1348:	18 98       	cbi	0x03, 0	; 3
			sbi(DDRE,3);	sbi(PORTE,3);
    134a:	13 9a       	sbi	0x02, 3	; 2
    134c:	1b 9a       	sbi	0x03, 3	; 3
		
			temp = (0x01 & inp(PINE));
    134e:	81 b1       	in	r24, 0x01	; 1

			if(temp == 0x01)
    1350:	80 ff       	sbrs	r24, 0
    1352:	02 c0       	rjmp	.+4      	; 0x1358 <TouchSensor+0x74>
			{
				cbi(PORTE,3);						
    1354:	1b 98       	cbi	0x03, 3	; 3
    1356:	17 c0       	rjmp	.+46     	; 0x1386 <TouchSensor+0xa2>
				delayms(1);	
				return TRUE;
			}

			sbi(PORTE,3);
    1358:	1b 9a       	sbi	0x03, 3	; 3
    135a:	20 c0       	rjmp	.+64     	; 0x139c <TouchSensor+0xb8>
			return FALSE;
			break;

		case 5:
			cbi(DDRE,7);	cbi(PORTE,7);		
    135c:	17 98       	cbi	0x02, 7	; 2
    135e:	1f 98       	cbi	0x03, 7	; 3
			sbi(DDRF,5);	sbi(PORTF,5);
    1360:	80 91 61 00 	lds	r24, 0x0061
    1364:	80 62       	ori	r24, 0x20	; 32
    1366:	80 93 61 00 	sts	0x0061, r24
    136a:	80 91 62 00 	lds	r24, 0x0062
    136e:	80 62       	ori	r24, 0x20	; 32
    1370:	80 93 62 00 	sts	0x0062, r24
	
			temp = (0x80 & inp(PINE));
    1374:	81 b1       	in	r24, 0x01	; 1
    1376:	80 78       	andi	r24, 0x80	; 128
			
			if(temp == 0x80)
    1378:	80 38       	cpi	r24, 0x80	; 128
    137a:	59 f4       	brne	.+22     	; 0x1392 <TouchSensor+0xae>
			{
				cbi(PORTF,5);						
    137c:	80 91 62 00 	lds	r24, 0x0062
    1380:	8f 7d       	andi	r24, 0xDF	; 223
    1382:	80 93 62 00 	sts	0x0062, r24
				delayms(1);	
    1386:	81 e0       	ldi	r24, 0x01	; 1
    1388:	90 e0       	ldi	r25, 0x00	; 0
    138a:	0e 94 55 06 	call	0xcaa	; 0xcaa <delayms>
				return TRUE;
    138e:	81 e0       	ldi	r24, 0x01	; 1
    1390:	08 95       	ret
			}

			sbi(PORTF,5);
    1392:	80 91 62 00 	lds	r24, 0x0062
    1396:	80 62       	ori	r24, 0x20	; 32
    1398:	80 93 62 00 	sts	0x0062, r24
			return FALSE;
    139c:	80 e0       	ldi	r24, 0x00	; 0
    139e:	08 95       	ret
		default:
			break;	

	}

}
    13a0:	08 95       	ret

000013a2 <Bulldozer>:

//---------------------------------------------------------
bool Bulldozer(u08 state)
{

	outp(0xfc, DDRC);
    13a2:	9c ef       	ldi	r25, 0xFC	; 252
    13a4:	94 bb       	out	0x14, r25	; 20
	outp(0xff, PORTC);
    13a6:	9f ef       	ldi	r25, 0xFF	; 255
    13a8:	95 bb       	out	0x15, r25	; 21

	if(inp(PINC)==state)    
    13aa:	23 b3       	in	r18, 0x13	; 19
		return TRUE;
    13ac:	91 e0       	ldi	r25, 0x01	; 1
    13ae:	28 13       	cpse	r18, r24
    13b0:	90 e0       	ldi	r25, 0x00	; 0
    else
		return FALSE;

}
    13b2:	89 2f       	mov	r24, r25
    13b4:	08 95       	ret

000013b6 <Buzzer>:


//---------------------------------------------------------
void Buzzer(u08 pos,u08 num)
{
    13b6:	df 92       	push	r13
    13b8:	ef 92       	push	r14
    13ba:	ff 92       	push	r15
    13bc:	0f 93       	push	r16
    13be:	1f 93       	push	r17
    13c0:	cf 93       	push	r28
    13c2:	df 93       	push	r29
    13c4:	d8 2e       	mov	r13, r24

	int i,k;

	for(i=0;i<num;i++){
    13c6:	c0 e0       	ldi	r28, 0x00	; 0
    13c8:	d0 e0       	ldi	r29, 0x00	; 0
    13ca:	06 2f       	mov	r16, r22
    13cc:	10 e0       	ldi	r17, 0x00	; 0
		Beep(pos);	
		if(i==num-1) break;
    13ce:	78 01       	movw	r14, r16
    13d0:	08 94       	sec
    13d2:	e1 08       	sbc	r14, r1
    13d4:	f1 08       	sbc	r15, r1
void Buzzer(u08 pos,u08 num)
{

	int i,k;

	for(i=0;i<num;i++){
    13d6:	0c c0       	rjmp	.+24     	; 0x13f0 <Buzzer+0x3a>
		Beep(pos);	
    13d8:	8d 2d       	mov	r24, r13
    13da:	90 e0       	ldi	r25, 0x00	; 0
    13dc:	0e 94 7a 07 	call	0xef4	; 0xef4 <Beep>
		if(i==num-1) break;
    13e0:	ce 15       	cp	r28, r14
    13e2:	df 05       	cpc	r29, r15
    13e4:	41 f0       	breq	.+16     	; 0x13f6 <Buzzer+0x40>
		delayms(600);
    13e6:	88 e5       	ldi	r24, 0x58	; 88
    13e8:	92 e0       	ldi	r25, 0x02	; 2
    13ea:	0e 94 55 06 	call	0xcaa	; 0xcaa <delayms>
void Buzzer(u08 pos,u08 num)
{

	int i,k;

	for(i=0;i<num;i++){
    13ee:	21 96       	adiw	r28, 0x01	; 1
    13f0:	c0 17       	cp	r28, r16
    13f2:	d1 07       	cpc	r29, r17
    13f4:	8c f3       	brlt	.-30     	; 0x13d8 <Buzzer+0x22>
		Beep(pos);	
		if(i==num-1) break;
		delayms(600);
	}		

}	
    13f6:	df 91       	pop	r29
    13f8:	cf 91       	pop	r28
    13fa:	1f 91       	pop	r17
    13fc:	0f 91       	pop	r16
    13fe:	ff 90       	pop	r15
    1400:	ef 90       	pop	r14
    1402:	df 90       	pop	r13
    1404:	08 95       	ret

00001406 <LcdDisplay>:


//---------------------------------------------------------
void LcdDisplay(char* msg1,char* msg2)
{
    1406:	ef 92       	push	r14
    1408:	ff 92       	push	r15
    140a:	0f 93       	push	r16
    140c:	1f 93       	push	r17
    140e:	cf 93       	push	r28
    1410:	df 93       	push	r29
    1412:	8c 01       	movw	r16, r24
    1414:	eb 01       	movw	r28, r22

	unsigned char find1,find2,SaveVal1,SaveVal2,cnt;
	unsigned char cnt1 = 0, cnt2 = 0; 

		SaveVal1 = text1;
    1416:	50 91 48 01 	lds	r21, 0x0148
		SaveVal2 = text2;
    141a:	f0 90 49 01 	lds	r15, 0x0149
    141e:	fc 01       	movw	r30, r24
	
		for(cnt=0;cnt<9;cnt++){
    1420:	90 e0       	ldi	r25, 0x00	; 0
    1422:	01 c0       	rjmp	.+2      	; 0x1426 <LcdDisplay+0x20>
    1424:	98 2f       	mov	r25, r24
			find1=msg1[cnt];
    1426:	81 91       	ld	r24, Z+
			text1 = cnt;
			if(find1 == 0) break;   
    1428:	88 23       	and	r24, r24
    142a:	21 f4       	brne	.+8      	; 0x1434 <LcdDisplay+0x2e>
    142c:	90 93 48 01 	sts	0x0148, r25
		SaveVal1 = text1;
		SaveVal2 = text2;
	
		for(cnt=0;cnt<9;cnt++){
			find1=msg1[cnt];
			text1 = cnt;
    1430:	80 e0       	ldi	r24, 0x00	; 0
    1432:	06 c0       	rjmp	.+12     	; 0x1440 <LcdDisplay+0x3a>
	unsigned char cnt1 = 0, cnt2 = 0; 

		SaveVal1 = text1;
		SaveVal2 = text2;
	
		for(cnt=0;cnt<9;cnt++){
    1434:	89 2f       	mov	r24, r25
    1436:	8f 5f       	subi	r24, 0xFF	; 255
    1438:	89 30       	cpi	r24, 0x09	; 9
    143a:	a1 f7       	brne	.-24     	; 0x1424 <LcdDisplay+0x1e>
    143c:	f7 cf       	rjmp	.-18     	; 0x142c <LcdDisplay+0x26>
			find1=msg1[cnt];
			text1 = cnt;
			if(find1 == 0) break;   
		}

		for(cnt=0;cnt<9;cnt++){
    143e:	82 2f       	mov	r24, r18
			find2=msg2[cnt];
    1440:	fe 01       	movw	r30, r28
    1442:	e8 0f       	add	r30, r24
    1444:	f1 1d       	adc	r31, r1
			text2 = cnt;
			if(find2 == 0) break;
    1446:	20 81       	ld	r18, Z
    1448:	22 23       	and	r18, r18
    144a:	29 f4       	brne	.+10     	; 0x1456 <LcdDisplay+0x50>
    144c:	80 93 49 01 	sts	0x0149, r24
			if(find1 == 0) break;   
		}

		for(cnt=0;cnt<9;cnt++){
			find2=msg2[cnt];
			text2 = cnt;
    1450:	60 e0       	ldi	r22, 0x00	; 0
    1452:	40 e0       	ldi	r20, 0x00	; 0
    1454:	17 c0       	rjmp	.+46     	; 0x1484 <LcdDisplay+0x7e>
			find1=msg1[cnt];
			text1 = cnt;
			if(find1 == 0) break;   
		}

		for(cnt=0;cnt<9;cnt++){
    1456:	28 2f       	mov	r18, r24
    1458:	2f 5f       	subi	r18, 0xFF	; 255
    145a:	29 30       	cpi	r18, 0x09	; 9
    145c:	81 f7       	brne	.-32     	; 0x143e <LcdDisplay+0x38>
    145e:	f6 cf       	rjmp	.-20     	; 0x144c <LcdDisplay+0x46>
			text2 = cnt;
			if(find2 == 0) break;
		} 

		for(cnt=0; cnt<text1; cnt++){
			if(string1[cnt] == msg1[cnt])	cnt1+=1;  
    1460:	24 2f       	mov	r18, r20
    1462:	30 e0       	ldi	r19, 0x00	; 0
    1464:	f8 01       	movw	r30, r16
    1466:	e2 0f       	add	r30, r18
    1468:	f3 1f       	adc	r31, r19
    146a:	70 81       	ld	r23, Z
    146c:	f9 01       	movw	r30, r18
    146e:	ee 57       	subi	r30, 0x7E	; 126
    1470:	fe 4f       	sbci	r31, 0xFE	; 254
    1472:	e0 81       	ld	r30, Z
    1474:	e7 17       	cp	r30, r23
    1476:	09 f4       	brne	.+2      	; 0x147a <LcdDisplay+0x74>
    1478:	6f 5f       	subi	r22, 0xFF	; 255
			string1[cnt] = msg1[cnt];
    147a:	2e 57       	subi	r18, 0x7E	; 126
    147c:	3e 4f       	sbci	r19, 0xFE	; 254
    147e:	f9 01       	movw	r30, r18
    1480:	70 83       	st	Z, r23
			find2=msg2[cnt];
			text2 = cnt;
			if(find2 == 0) break;
		} 

		for(cnt=0; cnt<text1; cnt++){
    1482:	4f 5f       	subi	r20, 0xFF	; 255
    1484:	49 17       	cp	r20, r25
    1486:	60 f3       	brcs	.-40     	; 0x1460 <LcdDisplay+0x5a>
    1488:	e1 e6       	ldi	r30, 0x61	; 97
    148a:	f1 e0       	ldi	r31, 0x01	; 1
    148c:	de 01       	movw	r26, r28

}	


//---------------------------------------------------------
void LcdDisplay(char* msg1,char* msg2)
    148e:	90 e0       	ldi	r25, 0x00	; 0
    1490:	8e 0f       	add	r24, r30
    1492:	9f 1f       	adc	r25, r31
    1494:	ee 24       	eor	r14, r14
    1496:	06 c0       	rjmp	.+12     	; 0x14a4 <LcdDisplay+0x9e>
			if(string1[cnt] == msg1[cnt])	cnt1+=1;  
			string1[cnt] = msg1[cnt];
		}  

		for(cnt=0; cnt<text2; cnt++){
			if(string2[cnt] == msg2[cnt])	cnt2+=1;   
    1498:	2d 91       	ld	r18, X+
    149a:	30 81       	ld	r19, Z
    149c:	32 17       	cp	r19, r18
    149e:	09 f4       	brne	.+2      	; 0x14a2 <LcdDisplay+0x9c>
    14a0:	e3 94       	inc	r14
			string2[cnt] = msg2[cnt];
    14a2:	21 93       	st	Z+, r18
		for(cnt=0; cnt<text1; cnt++){
			if(string1[cnt] == msg1[cnt])	cnt1+=1;  
			string1[cnt] = msg1[cnt];
		}  

		for(cnt=0; cnt<text2; cnt++){
    14a4:	e8 17       	cp	r30, r24
    14a6:	f9 07       	cpc	r31, r25
    14a8:	b9 f7       	brne	.-18     	; 0x1498 <LcdDisplay+0x92>
			if(string2[cnt] == msg2[cnt])	cnt2+=1;   
			string2[cnt] = msg2[cnt];
		}
	
	if(cnt1==SaveVal1){
    14aa:	65 17       	cp	r22, r21
    14ac:	31 f0       	breq	.+12     	; 0x14ba <LcdDisplay+0xb4>
		lcd_str_out(1,1,msg1);
	}else{
		lcd_str_out(1,1,empty);
    14ae:	81 e0       	ldi	r24, 0x01	; 1
    14b0:	61 e0       	ldi	r22, 0x01	; 1
    14b2:	43 e3       	ldi	r20, 0x33	; 51
    14b4:	51 e0       	ldi	r21, 0x01	; 1
    14b6:	0e 94 22 07 	call	0xe44	; 0xe44 <lcd_str_out>
		lcd_str_out(1,1,msg1);
    14ba:	81 e0       	ldi	r24, 0x01	; 1
    14bc:	61 e0       	ldi	r22, 0x01	; 1
    14be:	a8 01       	movw	r20, r16
    14c0:	0e 94 22 07 	call	0xe44	; 0xe44 <lcd_str_out>
	}

	if(cnt2==SaveVal2){
    14c4:	ef 14       	cp	r14, r15
    14c6:	31 f0       	breq	.+12     	; 0x14d4 <LcdDisplay+0xce>
		lcd_str_out(2,1,msg2);
	}else{
		lcd_str_out(2,1,empty);
    14c8:	82 e0       	ldi	r24, 0x02	; 2
    14ca:	61 e0       	ldi	r22, 0x01	; 1
    14cc:	43 e3       	ldi	r20, 0x33	; 51
    14ce:	51 e0       	ldi	r21, 0x01	; 1
    14d0:	0e 94 22 07 	call	0xe44	; 0xe44 <lcd_str_out>
		lcd_str_out(2,1,msg2);
    14d4:	82 e0       	ldi	r24, 0x02	; 2
    14d6:	61 e0       	ldi	r22, 0x01	; 1
    14d8:	ae 01       	movw	r20, r28
    14da:	0e 94 22 07 	call	0xe44	; 0xe44 <lcd_str_out>
	}    

}
    14de:	df 91       	pop	r29
    14e0:	cf 91       	pop	r28
    14e2:	1f 91       	pop	r17
    14e4:	0f 91       	pop	r16
    14e6:	ff 90       	pop	r15
    14e8:	ef 90       	pop	r14
    14ea:	08 95       	ret

000014ec <DC_Control>:
//---------------------------------------------------------
void DC_Control(u08 pos,u08 sel_motor,u08 pwm_value,u08 direction)
{
//	m_nPwmPeriod = 0;

	if(pos == 0){
    14ec:	88 23       	and	r24, r24
    14ee:	19 f4       	brne	.+6      	; 0x14f6 <DC_Control+0xa>
		DcMotor_temp(direction,sel_motor,pwm_value);
    14f0:	82 2f       	mov	r24, r18
    14f2:	0e 94 2e 05 	call	0xa5c	; 0xa5c <DcMotor_temp>
    14f6:	08 95       	ret

000014f8 <LEDModuleCtrl>:
{

	static u08 swvalue = 0;
	u08 LedState,i;

	switch(position){
    14f8:	83 30       	cpi	r24, 0x03	; 3
    14fa:	09 f4       	brne	.+2      	; 0x14fe <LEDModuleCtrl+0x6>
    14fc:	5f c0       	rjmp	.+190    	; 0x15bc <LEDModuleCtrl+0xc4>
    14fe:	84 30       	cpi	r24, 0x04	; 4
    1500:	30 f4       	brcc	.+12     	; 0x150e <LEDModuleCtrl+0x16>
    1502:	81 30       	cpi	r24, 0x01	; 1
    1504:	59 f0       	breq	.+22     	; 0x151c <LEDModuleCtrl+0x24>
    1506:	82 30       	cpi	r24, 0x02	; 2
    1508:	09 f0       	breq	.+2      	; 0x150c <LEDModuleCtrl+0x14>
    150a:	ee c0       	rjmp	.+476    	; 0x16e8 <LEDModuleCtrl+0x1f0>
    150c:	2f c0       	rjmp	.+94     	; 0x156c <LEDModuleCtrl+0x74>
    150e:	84 30       	cpi	r24, 0x04	; 4
    1510:	09 f4       	brne	.+2      	; 0x1514 <LEDModuleCtrl+0x1c>
    1512:	7e c0       	rjmp	.+252    	; 0x1610 <LEDModuleCtrl+0x118>
    1514:	85 30       	cpi	r24, 0x05	; 5
    1516:	09 f0       	breq	.+2      	; 0x151a <LEDModuleCtrl+0x22>
    1518:	e7 c0       	rjmp	.+462    	; 0x16e8 <LEDModuleCtrl+0x1f0>
    151a:	a2 c0       	rjmp	.+324    	; 0x1660 <LEDModuleCtrl+0x168>
		case 1:			//Module_1
			sbi(DDRB , 0);	sbi(DDRB , 1);	sbi(DDRB , 2);	sbi(DDRB , 3);	//LED port initialize
    151c:	b8 9a       	sbi	0x17, 0	; 23
    151e:	b9 9a       	sbi	0x17, 1	; 23
    1520:	ba 9a       	sbi	0x17, 2	; 23
    1522:	bb 9a       	sbi	0x17, 3	; 23
    1524:	80 e0       	ldi	r24, 0x00	; 0
    1526:	90 e0       	ldi	r25, 0x00	; 0
			for(i=0; i<4; i++)
			{
				LedState = index%2;                  
				index = index >> 1;
				if(LedState == 1) cbi(PORTB, i);  
				else sbi(PORTB,i);
    1528:	21 e0       	ldi	r18, 0x01	; 1
    152a:	30 e0       	ldi	r19, 0x00	; 0
		case 1:			//Module_1
			sbi(DDRB , 0);	sbi(DDRB , 1);	sbi(DDRB , 2);	sbi(DDRB , 3);	//LED port initialize

			for(i=0; i<4; i++)
			{
				LedState = index%2;                  
    152c:	46 2f       	mov	r20, r22
    152e:	41 70       	andi	r20, 0x01	; 1
				index = index >> 1;
    1530:	66 95       	lsr	r22
				if(LedState == 1) cbi(PORTB, i);  
    1532:	41 30       	cpi	r20, 0x01	; 1
    1534:	61 f4       	brne	.+24     	; 0x154e <LEDModuleCtrl+0x56>
    1536:	78 b3       	in	r23, 0x18	; 24
    1538:	a9 01       	movw	r20, r18
    153a:	08 2e       	mov	r0, r24
    153c:	02 c0       	rjmp	.+4      	; 0x1542 <LEDModuleCtrl+0x4a>
    153e:	44 0f       	add	r20, r20
    1540:	55 1f       	adc	r21, r21
    1542:	0a 94       	dec	r0
    1544:	e2 f7       	brpl	.-8      	; 0x153e <LEDModuleCtrl+0x46>
    1546:	40 95       	com	r20
    1548:	47 23       	and	r20, r23
    154a:	48 bb       	out	0x18, r20	; 24
    154c:	0a c0       	rjmp	.+20     	; 0x1562 <LEDModuleCtrl+0x6a>
				else sbi(PORTB,i);
    154e:	78 b3       	in	r23, 0x18	; 24
    1550:	a9 01       	movw	r20, r18
    1552:	08 2e       	mov	r0, r24
    1554:	02 c0       	rjmp	.+4      	; 0x155a <LEDModuleCtrl+0x62>
    1556:	44 0f       	add	r20, r20
    1558:	55 1f       	adc	r21, r21
    155a:	0a 94       	dec	r0
    155c:	e2 f7       	brpl	.-8      	; 0x1556 <LEDModuleCtrl+0x5e>
    155e:	74 2b       	or	r23, r20
    1560:	78 bb       	out	0x18, r23	; 24
    1562:	01 96       	adiw	r24, 0x01	; 1

	switch(position){
		case 1:			//Module_1
			sbi(DDRB , 0);	sbi(DDRB , 1);	sbi(DDRB , 2);	sbi(DDRB , 3);	//LED port initialize

			for(i=0; i<4; i++)
    1564:	84 30       	cpi	r24, 0x04	; 4
    1566:	91 05       	cpc	r25, r1
    1568:	09 f7       	brne	.-62     	; 0x152c <LEDModuleCtrl+0x34>
    156a:	08 95       	ret
				else sbi(PORTB,i);
			}
			break;

		case 2:
			sbi(DDRD ,0 );	sbi(DDRD ,1 );	sbi(DDRD ,2 );	sbi(DDRD ,3 );
    156c:	88 9a       	sbi	0x11, 0	; 17
    156e:	89 9a       	sbi	0x11, 1	; 17
    1570:	8a 9a       	sbi	0x11, 2	; 17
    1572:	8b 9a       	sbi	0x11, 3	; 17
    1574:	80 e0       	ldi	r24, 0x00	; 0
    1576:	90 e0       	ldi	r25, 0x00	; 0
			for(i=0; i<4; i++)
			{
				LedState = index%2;                  
				index = index >> 1;
				if(LedState == 1) cbi(PORTD, i);
				else sbi(PORTD,i);
    1578:	21 e0       	ldi	r18, 0x01	; 1
    157a:	30 e0       	ldi	r19, 0x00	; 0
		case 2:
			sbi(DDRD ,0 );	sbi(DDRD ,1 );	sbi(DDRD ,2 );	sbi(DDRD ,3 );
			
			for(i=0; i<4; i++)
			{
				LedState = index%2;                  
    157c:	46 2f       	mov	r20, r22
    157e:	41 70       	andi	r20, 0x01	; 1
				index = index >> 1;
    1580:	66 95       	lsr	r22
				if(LedState == 1) cbi(PORTD, i);
    1582:	41 30       	cpi	r20, 0x01	; 1
    1584:	61 f4       	brne	.+24     	; 0x159e <LEDModuleCtrl+0xa6>
    1586:	72 b3       	in	r23, 0x12	; 18
    1588:	a9 01       	movw	r20, r18
    158a:	08 2e       	mov	r0, r24
    158c:	02 c0       	rjmp	.+4      	; 0x1592 <LEDModuleCtrl+0x9a>
    158e:	44 0f       	add	r20, r20
    1590:	55 1f       	adc	r21, r21
    1592:	0a 94       	dec	r0
    1594:	e2 f7       	brpl	.-8      	; 0x158e <LEDModuleCtrl+0x96>
    1596:	40 95       	com	r20
    1598:	47 23       	and	r20, r23
    159a:	42 bb       	out	0x12, r20	; 18
    159c:	0a c0       	rjmp	.+20     	; 0x15b2 <LEDModuleCtrl+0xba>
				else sbi(PORTD,i);
    159e:	72 b3       	in	r23, 0x12	; 18
    15a0:	a9 01       	movw	r20, r18
    15a2:	08 2e       	mov	r0, r24
    15a4:	02 c0       	rjmp	.+4      	; 0x15aa <LEDModuleCtrl+0xb2>
    15a6:	44 0f       	add	r20, r20
    15a8:	55 1f       	adc	r21, r21
    15aa:	0a 94       	dec	r0
    15ac:	e2 f7       	brpl	.-8      	; 0x15a6 <LEDModuleCtrl+0xae>
    15ae:	74 2b       	or	r23, r20
    15b0:	72 bb       	out	0x12, r23	; 18
    15b2:	01 96       	adiw	r24, 0x01	; 1
			break;

		case 2:
			sbi(DDRD ,0 );	sbi(DDRD ,1 );	sbi(DDRD ,2 );	sbi(DDRD ,3 );
			
			for(i=0; i<4; i++)
    15b4:	84 30       	cpi	r24, 0x04	; 4
    15b6:	91 05       	cpc	r25, r1
    15b8:	09 f7       	brne	.-62     	; 0x157c <LEDModuleCtrl+0x84>
    15ba:	08 95       	ret
				else sbi(PORTD,i);
			}
			break;

		case 3:
			sbi(DDRD, 4);	sbi(DDRD ,5);	sbi(DDRD ,6);	sbi(DDRD ,7);
    15bc:	8c 9a       	sbi	0x11, 4	; 17
    15be:	8d 9a       	sbi	0x11, 5	; 17
    15c0:	8e 9a       	sbi	0x11, 6	; 17
    15c2:	8f 9a       	sbi	0x11, 7	; 17
    15c4:	80 e0       	ldi	r24, 0x00	; 0
    15c6:	90 e0       	ldi	r25, 0x00	; 0
			for(i=4; i<8; i++)
			{
				LedState = index%2;                  
				index = index >> 1;
				if(LedState == 1) cbi(PORTD, i);
				else sbi(PORTD,i);
    15c8:	21 e0       	ldi	r18, 0x01	; 1
    15ca:	30 e0       	ldi	r19, 0x00	; 0
		case 3:
			sbi(DDRD, 4);	sbi(DDRD ,5);	sbi(DDRD ,6);	sbi(DDRD ,7);

			for(i=4; i<8; i++)
			{
				LedState = index%2;                  
    15cc:	76 2f       	mov	r23, r22
    15ce:	71 70       	andi	r23, 0x01	; 1
				index = index >> 1;
    15d0:	66 95       	lsr	r22
    15d2:	ac 01       	movw	r20, r24
    15d4:	4c 5f       	subi	r20, 0xFC	; 252
    15d6:	5f 4f       	sbci	r21, 0xFF	; 255
				if(LedState == 1) cbi(PORTD, i);
    15d8:	71 30       	cpi	r23, 0x01	; 1
    15da:	61 f4       	brne	.+24     	; 0x15f4 <LEDModuleCtrl+0xfc>
    15dc:	72 b3       	in	r23, 0x12	; 18
    15de:	f9 01       	movw	r30, r18
    15e0:	02 c0       	rjmp	.+4      	; 0x15e6 <LEDModuleCtrl+0xee>
    15e2:	ee 0f       	add	r30, r30
    15e4:	ff 1f       	adc	r31, r31
    15e6:	4a 95       	dec	r20
    15e8:	e2 f7       	brpl	.-8      	; 0x15e2 <LEDModuleCtrl+0xea>
    15ea:	af 01       	movw	r20, r30
    15ec:	40 95       	com	r20
    15ee:	47 23       	and	r20, r23
    15f0:	42 bb       	out	0x12, r20	; 18
    15f2:	09 c0       	rjmp	.+18     	; 0x1606 <LEDModuleCtrl+0x10e>
				else sbi(PORTD,i);
    15f4:	72 b3       	in	r23, 0x12	; 18
    15f6:	f9 01       	movw	r30, r18
    15f8:	02 c0       	rjmp	.+4      	; 0x15fe <LEDModuleCtrl+0x106>
    15fa:	ee 0f       	add	r30, r30
    15fc:	ff 1f       	adc	r31, r31
    15fe:	4a 95       	dec	r20
    1600:	e2 f7       	brpl	.-8      	; 0x15fa <LEDModuleCtrl+0x102>
    1602:	7e 2b       	or	r23, r30
    1604:	72 bb       	out	0x12, r23	; 18
    1606:	01 96       	adiw	r24, 0x01	; 1
			break;

		case 3:
			sbi(DDRD, 4);	sbi(DDRD ,5);	sbi(DDRD ,6);	sbi(DDRD ,7);

			for(i=4; i<8; i++)
    1608:	84 30       	cpi	r24, 0x04	; 4
    160a:	91 05       	cpc	r25, r1
    160c:	f9 f6       	brne	.-66     	; 0x15cc <LEDModuleCtrl+0xd4>
    160e:	08 95       	ret
				else sbi(PORTD,i);
			}
			break;

		case 4:
			sbi(DDRE , 0);	sbi(DDRE , 1);	sbi(DDRE , 2);	sbi(DDRE , 3);
    1610:	10 9a       	sbi	0x02, 0	; 2
    1612:	11 9a       	sbi	0x02, 1	; 2
    1614:	12 9a       	sbi	0x02, 2	; 2
    1616:	13 9a       	sbi	0x02, 3	; 2
    1618:	80 e0       	ldi	r24, 0x00	; 0
    161a:	90 e0       	ldi	r25, 0x00	; 0
			for(i=0; i<4; i++)
			{
				LedState = index%2;                  
				index = index >> 1;
				if(LedState == 1) cbi(PORTE, i);
				else sbi(PORTE,i);
    161c:	21 e0       	ldi	r18, 0x01	; 1
    161e:	30 e0       	ldi	r19, 0x00	; 0
		case 4:
			sbi(DDRE , 0);	sbi(DDRE , 1);	sbi(DDRE , 2);	sbi(DDRE , 3);
		
			for(i=0; i<4; i++)
			{
				LedState = index%2;                  
    1620:	46 2f       	mov	r20, r22
    1622:	41 70       	andi	r20, 0x01	; 1
				index = index >> 1;
    1624:	66 95       	lsr	r22
				if(LedState == 1) cbi(PORTE, i);
    1626:	41 30       	cpi	r20, 0x01	; 1
    1628:	61 f4       	brne	.+24     	; 0x1642 <LEDModuleCtrl+0x14a>
    162a:	73 b1       	in	r23, 0x03	; 3
    162c:	a9 01       	movw	r20, r18
    162e:	08 2e       	mov	r0, r24
    1630:	02 c0       	rjmp	.+4      	; 0x1636 <LEDModuleCtrl+0x13e>
    1632:	44 0f       	add	r20, r20
    1634:	55 1f       	adc	r21, r21
    1636:	0a 94       	dec	r0
    1638:	e2 f7       	brpl	.-8      	; 0x1632 <LEDModuleCtrl+0x13a>
    163a:	40 95       	com	r20
    163c:	47 23       	and	r20, r23
    163e:	43 b9       	out	0x03, r20	; 3
    1640:	0a c0       	rjmp	.+20     	; 0x1656 <LEDModuleCtrl+0x15e>
				else sbi(PORTE,i);
    1642:	73 b1       	in	r23, 0x03	; 3
    1644:	a9 01       	movw	r20, r18
    1646:	08 2e       	mov	r0, r24
    1648:	02 c0       	rjmp	.+4      	; 0x164e <LEDModuleCtrl+0x156>
    164a:	44 0f       	add	r20, r20
    164c:	55 1f       	adc	r21, r21
    164e:	0a 94       	dec	r0
    1650:	e2 f7       	brpl	.-8      	; 0x164a <LEDModuleCtrl+0x152>
    1652:	74 2b       	or	r23, r20
    1654:	73 b9       	out	0x03, r23	; 3
    1656:	01 96       	adiw	r24, 0x01	; 1
			break;

		case 4:
			sbi(DDRE , 0);	sbi(DDRE , 1);	sbi(DDRE , 2);	sbi(DDRE , 3);
		
			for(i=0; i<4; i++)
    1658:	84 30       	cpi	r24, 0x04	; 4
    165a:	91 05       	cpc	r25, r1
    165c:	09 f7       	brne	.-62     	; 0x1620 <LEDModuleCtrl+0x128>
    165e:	08 95       	ret
				else sbi(PORTE,i);
			}
			break;

		case 5:
			sbi(DDRE ,7 );	sbi(DDRG ,3 );	sbi(DDRG ,4 );	sbi(DDRF ,5 );
    1660:	17 9a       	sbi	0x02, 7	; 2
    1662:	80 91 64 00 	lds	r24, 0x0064
    1666:	88 60       	ori	r24, 0x08	; 8
    1668:	80 93 64 00 	sts	0x0064, r24
    166c:	80 91 64 00 	lds	r24, 0x0064
    1670:	80 61       	ori	r24, 0x10	; 16
    1672:	80 93 64 00 	sts	0x0064, r24
    1676:	80 91 61 00 	lds	r24, 0x0061
    167a:	80 62       	ori	r24, 0x20	; 32
    167c:	80 93 61 00 	sts	0x0061, r24
			
			for(i=0; i<4; i++)
    1680:	80 e0       	ldi	r24, 0x00	; 0
			{
				LedState = index%2;                  
    1682:	96 2f       	mov	r25, r22
    1684:	91 70       	andi	r25, 0x01	; 1
				index = index >> 1;
    1686:	66 95       	lsr	r22
				switch(i)
    1688:	82 30       	cpi	r24, 0x02	; 2
    168a:	a1 f0       	breq	.+40     	; 0x16b4 <LEDModuleCtrl+0x1bc>
    168c:	83 30       	cpi	r24, 0x03	; 3
    168e:	f1 f0       	breq	.+60     	; 0x16cc <LEDModuleCtrl+0x1d4>
    1690:	81 30       	cpi	r24, 0x01	; 1
    1692:	31 f0       	breq	.+12     	; 0x16a0 <LEDModuleCtrl+0x1a8>
				{
					case 0:		if(LedState == 1) cbi(PORTE, 7);
    1694:	91 30       	cpi	r25, 0x01	; 1
    1696:	11 f4       	brne	.+4      	; 0x169c <LEDModuleCtrl+0x1a4>
    1698:	1f 98       	cbi	0x03, 7	; 3
    169a:	23 c0       	rjmp	.+70     	; 0x16e2 <LEDModuleCtrl+0x1ea>
								else sbi(PORTE,7);
    169c:	1f 9a       	sbi	0x03, 7	; 3
    169e:	21 c0       	rjmp	.+66     	; 0x16e2 <LEDModuleCtrl+0x1ea>
								break;
					case 1:		if(LedState == 1) cbi(PORTG, 3);
    16a0:	91 30       	cpi	r25, 0x01	; 1
    16a2:	21 f4       	brne	.+8      	; 0x16ac <LEDModuleCtrl+0x1b4>
    16a4:	90 91 65 00 	lds	r25, 0x0065
    16a8:	97 7f       	andi	r25, 0xF7	; 247
    16aa:	0d c0       	rjmp	.+26     	; 0x16c6 <LEDModuleCtrl+0x1ce>
								else sbi(PORTG,3);
    16ac:	90 91 65 00 	lds	r25, 0x0065
    16b0:	98 60       	ori	r25, 0x08	; 8
    16b2:	09 c0       	rjmp	.+18     	; 0x16c6 <LEDModuleCtrl+0x1ce>
								break;
					case 2:		if(LedState == 1) cbi(PORTG, 4);
    16b4:	91 30       	cpi	r25, 0x01	; 1
    16b6:	21 f4       	brne	.+8      	; 0x16c0 <LEDModuleCtrl+0x1c8>
    16b8:	90 91 65 00 	lds	r25, 0x0065
    16bc:	9f 7e       	andi	r25, 0xEF	; 239
    16be:	03 c0       	rjmp	.+6      	; 0x16c6 <LEDModuleCtrl+0x1ce>
								else sbi(PORTG,4);
    16c0:	90 91 65 00 	lds	r25, 0x0065
    16c4:	90 61       	ori	r25, 0x10	; 16
    16c6:	90 93 65 00 	sts	0x0065, r25
    16ca:	0b c0       	rjmp	.+22     	; 0x16e2 <LEDModuleCtrl+0x1ea>
								break;
					case 3:		if(LedState == 1) cbi(PORTF, 5);
    16cc:	91 30       	cpi	r25, 0x01	; 1
    16ce:	21 f4       	brne	.+8      	; 0x16d8 <LEDModuleCtrl+0x1e0>
    16d0:	90 91 62 00 	lds	r25, 0x0062
    16d4:	9f 7d       	andi	r25, 0xDF	; 223
    16d6:	03 c0       	rjmp	.+6      	; 0x16de <LEDModuleCtrl+0x1e6>
								else sbi(PORTF,5);
    16d8:	90 91 62 00 	lds	r25, 0x0062
    16dc:	90 62       	ori	r25, 0x20	; 32
    16de:	90 93 62 00 	sts	0x0062, r25
			break;

		case 5:
			sbi(DDRE ,7 );	sbi(DDRG ,3 );	sbi(DDRG ,4 );	sbi(DDRF ,5 );
			
			for(i=0; i<4; i++)
    16e2:	8f 5f       	subi	r24, 0xFF	; 255
    16e4:	84 30       	cpi	r24, 0x04	; 4
    16e6:	69 f6       	brne	.-102    	; 0x1682 <LEDModuleCtrl+0x18a>
    16e8:	08 95       	ret

000016ea <MelodyPlay>:

//---------------------------------------------------------
void MelodyPlay(u08 pos,u08 melody)
{

	switch(melody)
    16ea:	65 30       	cpi	r22, 0x05	; 5
    16ec:	91 f1       	breq	.+100    	; 0x1752 <MelodyPlay+0x68>
    16ee:	66 30       	cpi	r22, 0x06	; 6
    16f0:	70 f4       	brcc	.+28     	; 0x170e <MelodyPlay+0x24>
    16f2:	62 30       	cpi	r22, 0x02	; 2
    16f4:	f9 f0       	breq	.+62     	; 0x1734 <MelodyPlay+0x4a>
    16f6:	63 30       	cpi	r22, 0x03	; 3
    16f8:	20 f4       	brcc	.+8      	; 0x1702 <MelodyPlay+0x18>
    16fa:	61 30       	cpi	r22, 0x01	; 1
    16fc:	09 f0       	breq	.+2      	; 0x1700 <MelodyPlay+0x16>
    16fe:	4a c0       	rjmp	.+148    	; 0x1794 <MelodyPlay+0xaa>
    1700:	14 c0       	rjmp	.+40     	; 0x172a <MelodyPlay+0x40>
    1702:	63 30       	cpi	r22, 0x03	; 3
    1704:	e1 f0       	breq	.+56     	; 0x173e <MelodyPlay+0x54>
    1706:	64 30       	cpi	r22, 0x04	; 4
    1708:	09 f0       	breq	.+2      	; 0x170c <MelodyPlay+0x22>
    170a:	44 c0       	rjmp	.+136    	; 0x1794 <MelodyPlay+0xaa>
    170c:	1d c0       	rjmp	.+58     	; 0x1748 <MelodyPlay+0x5e>
    170e:	68 30       	cpi	r22, 0x08	; 8
    1710:	79 f1       	breq	.+94     	; 0x1770 <MelodyPlay+0x86>
    1712:	69 30       	cpi	r22, 0x09	; 9
    1714:	28 f4       	brcc	.+10     	; 0x1720 <MelodyPlay+0x36>
    1716:	66 30       	cpi	r22, 0x06	; 6
    1718:	09 f1       	breq	.+66     	; 0x175c <MelodyPlay+0x72>
    171a:	67 30       	cpi	r22, 0x07	; 7
    171c:	d9 f5       	brne	.+118    	; 0x1794 <MelodyPlay+0xaa>
    171e:	23 c0       	rjmp	.+70     	; 0x1766 <MelodyPlay+0x7c>
    1720:	69 30       	cpi	r22, 0x09	; 9
    1722:	59 f1       	breq	.+86     	; 0x177a <MelodyPlay+0x90>
    1724:	6a 30       	cpi	r22, 0x0A	; 10
    1726:	b1 f5       	brne	.+108    	; 0x1794 <MelodyPlay+0xaa>
    1728:	2f c0       	rjmp	.+94     	; 0x1788 <MelodyPlay+0x9e>
	{
	case 1:
		SetSpeaker(pos,MELODY_1, RHYTHM_EX_1);
    172a:	62 e2       	ldi	r22, 0x22	; 34
    172c:	71 e0       	ldi	r23, 0x01	; 1
    172e:	40 e3       	ldi	r20, 0x30	; 48
    1730:	51 e0       	ldi	r21, 0x01	; 1
    1732:	27 c0       	rjmp	.+78     	; 0x1782 <MelodyPlay+0x98>
		break;
	case 2:
		SetSpeaker(pos,MELODY_2, RHYTHM_EX_2);
    1734:	6d e3       	ldi	r22, 0x3D	; 61
    1736:	71 e0       	ldi	r23, 0x01	; 1
    1738:	4c e4       	ldi	r20, 0x4C	; 76
    173a:	51 e0       	ldi	r21, 0x01	; 1
    173c:	22 c0       	rjmp	.+68     	; 0x1782 <MelodyPlay+0x98>
		break;
	case 3:
		SetSpeaker(pos,MELODY_3, RHYTHM_EX_3);
    173e:	6a e5       	ldi	r22, 0x5A	; 90
    1740:	71 e0       	ldi	r23, 0x01	; 1
    1742:	4e e5       	ldi	r20, 0x5E	; 94
    1744:	51 e0       	ldi	r21, 0x01	; 1
    1746:	1d c0       	rjmp	.+58     	; 0x1782 <MelodyPlay+0x98>
		break;
	case 4:
		SetSpeaker(pos,MELODY_4, RHYTHM_EX_4);
    1748:	61 e6       	ldi	r22, 0x61	; 97
    174a:	71 e0       	ldi	r23, 0x01	; 1
    174c:	4b e7       	ldi	r20, 0x7B	; 123
    174e:	51 e0       	ldi	r21, 0x01	; 1
    1750:	18 c0       	rjmp	.+48     	; 0x1782 <MelodyPlay+0x98>
		break;
	case 5:
		SetSpeaker(pos,MELODY_5, RHYTHM_EX_5);
    1752:	64 e9       	ldi	r22, 0x94	; 148
    1754:	71 e0       	ldi	r23, 0x01	; 1
    1756:	48 e9       	ldi	r20, 0x98	; 152
    1758:	51 e0       	ldi	r21, 0x01	; 1
    175a:	13 c0       	rjmp	.+38     	; 0x1782 <MelodyPlay+0x98>
		break;
	case 6:
		SetSpeaker(pos,MELODY_6, RHYTHM_EX_6);
    175c:	6b e9       	ldi	r22, 0x9B	; 155
    175e:	71 e0       	ldi	r23, 0x01	; 1
    1760:	40 ea       	ldi	r20, 0xA0	; 160
    1762:	51 e0       	ldi	r21, 0x01	; 1
    1764:	0e c0       	rjmp	.+28     	; 0x1782 <MelodyPlay+0x98>
		break;
	case 7:
		SetSpeaker(pos,MELODY_7, RHYTHM_EX_7);
    1766:	64 ea       	ldi	r22, 0xA4	; 164
    1768:	71 e0       	ldi	r23, 0x01	; 1
    176a:	48 ea       	ldi	r20, 0xA8	; 168
    176c:	51 e0       	ldi	r21, 0x01	; 1
    176e:	09 c0       	rjmp	.+18     	; 0x1782 <MelodyPlay+0x98>
		break;
	case 8:
		SetSpeaker(pos,MELODY_8, RHYTHM_EX_8);
    1770:	6b ea       	ldi	r22, 0xAB	; 171
    1772:	71 e0       	ldi	r23, 0x01	; 1
    1774:	40 eb       	ldi	r20, 0xB0	; 176
    1776:	51 e0       	ldi	r21, 0x01	; 1
    1778:	04 c0       	rjmp	.+8      	; 0x1782 <MelodyPlay+0x98>
		break;
	case 9:
		SetSpeaker(pos,MELODY_9, RHYTHM_EX_9);
    177a:	64 eb       	ldi	r22, 0xB4	; 180
    177c:	71 e0       	ldi	r23, 0x01	; 1
    177e:	47 eb       	ldi	r20, 0xB7	; 183
    1780:	51 e0       	ldi	r21, 0x01	; 1
    1782:	0e 94 57 01 	call	0x2ae	; 0x2ae <SetSpeaker>
		break;
    1786:	08 95       	ret
	case 10:
		SetSpeaker(pos,MELODY_10, RHYTHM_EX_10);
    1788:	69 eb       	ldi	r22, 0xB9	; 185
    178a:	71 e0       	ldi	r23, 0x01	; 1
    178c:	4e eb       	ldi	r20, 0xBE	; 190
    178e:	51 e0       	ldi	r21, 0x01	; 1
    1790:	0e 94 57 01 	call	0x2ae	; 0x2ae <SetSpeaker>
    1794:	08 95       	ret

00001796 <Composition>:

//---------------------------------------------------------
void Composition(u08 pos,u08 *pTone,u08 *pRhythm)
{

    Mel = pTone;
    1796:	60 93 76 01 	sts	0x0176, r22
    179a:	70 93 77 01 	sts	0x0177, r23
    Kon = pRhythm;	
    179e:	40 93 eb 01 	sts	0x01EB, r20
    17a2:	50 93 ec 01 	sts	0x01EC, r21

	m_nPos_Speaker = pos;			
    17a6:	80 93 57 01 	sts	0x0157, r24
	pM_ = pM_refrash = Mel;			
    17aa:	60 93 6f 01 	sts	0x016F, r22
    17ae:	70 93 70 01 	sts	0x0170, r23
    17b2:	60 93 c1 01 	sts	0x01C1, r22
    17b6:	70 93 c2 01 	sts	0x01C2, r23
	pK_ = pK_refrash =  Kon;		
    17ba:	40 93 71 01 	sts	0x0171, r20
    17be:	50 93 72 01 	sts	0x0172, r21
    17c2:	40 93 e8 01 	sts	0x01E8, r20
    17c6:	50 93 e9 01 	sts	0x01E9, r21

	OvfCount 	= PRG_RDB(&Melody_Tof_count[PRG_RDB(pM_ )]);
    17ca:	fb 01       	movw	r30, r22
    17cc:	84 91       	lpm	r24, Z+
    17ce:	90 e0       	ldi	r25, 0x00	; 0
    17d0:	fc 01       	movw	r30, r24
    17d2:	e4 57       	subi	r30, 0x74	; 116
    17d4:	ff 4f       	sbci	r31, 0xFF	; 255
    17d6:	e4 91       	lpm	r30, Z+
    17d8:	e0 93 bc 01 	sts	0x01BC, r30
	SubTimeValue= PRG_RDB(&Melody_Sub_Time[PRG_RDB(pM_)]);	
    17dc:	82 55       	subi	r24, 0x52	; 82
    17de:	9f 4f       	sbci	r25, 0xFF	; 255
    17e0:	fc 01       	movw	r30, r24
    17e2:	84 91       	lpm	r24, Z+
    17e4:	80 93 81 01 	sts	0x0181, r24
	MelImpect = PRG_RDB(pK_);
    17e8:	fa 01       	movw	r30, r20
    17ea:	e4 91       	lpm	r30, Z+
    17ec:	e0 93 46 01 	sts	0x0146, r30
	KongCount 	= PRG_RDB(&Melody_Kongnamul[(0x0f&(PRG_RDB(pK_)))]);
    17f0:	f0 e0       	ldi	r31, 0x00	; 0
    17f2:	ef 70       	andi	r30, 0x0F	; 15
    17f4:	f0 70       	andi	r31, 0x00	; 0
    17f6:	e0 53       	subi	r30, 0x30	; 48
    17f8:	ff 4f       	sbci	r31, 0xFF	; 255
    17fa:	e4 91       	lpm	r30, Z+
    17fc:	e0 93 ee 01 	sts	0x01EE, r30

   	PLAYMELODY();		
    1800:	80 91 7c 01 	lds	r24, 0x017C
    1804:	88 60       	ori	r24, 0x08	; 8
    1806:	80 93 7c 01 	sts	0x017C, r24
   	MelodyRegister &= ~EEPPLAYFLAG;         
    180a:	80 91 7c 01 	lds	r24, 0x017C
    180e:	8f 7e       	andi	r24, 0xEF	; 239
    1810:	80 93 7c 01 	sts	0x017C, r24

    while(MelodyRegister & MelodyOnOffFLAG);     
    1814:	80 91 7c 01 	lds	r24, 0x017C
    1818:	83 fd       	sbrc	r24, 3
    181a:	fc cf       	rjmp	.-8      	; 0x1814 <Composition+0x7e>

}
    181c:	08 95       	ret

0000181e <fnd_display>:
//---------------------------------------------------------
void fnd_display(u08 pos,u08 val)
{

	u08 i,data;
	data = number_fnd[val];
    181e:	e6 2f       	mov	r30, r22
    1820:	f0 e0       	ldi	r31, 0x00	; 0
    1822:	ed 5d       	subi	r30, 0xDD	; 221
    1824:	fe 4f       	sbci	r31, 0xFE	; 254
    1826:	20 81       	ld	r18, Z

	switch(pos)
    1828:	83 30       	cpi	r24, 0x03	; 3
    182a:	09 f4       	brne	.+2      	; 0x182e <fnd_display+0x10>
    182c:	47 c0       	rjmp	.+142    	; 0x18bc <fnd_display+0x9e>
    182e:	84 30       	cpi	r24, 0x04	; 4
    1830:	30 f4       	brcc	.+12     	; 0x183e <fnd_display+0x20>
    1832:	81 30       	cpi	r24, 0x01	; 1
    1834:	59 f0       	breq	.+22     	; 0x184c <fnd_display+0x2e>
    1836:	82 30       	cpi	r24, 0x02	; 2
    1838:	09 f0       	breq	.+2      	; 0x183c <fnd_display+0x1e>
    183a:	ab c0       	rjmp	.+342    	; 0x1992 <fnd_display+0x174>
    183c:	23 c0       	rjmp	.+70     	; 0x1884 <fnd_display+0x66>
    183e:	84 30       	cpi	r24, 0x04	; 4
    1840:	09 f4       	brne	.+2      	; 0x1844 <fnd_display+0x26>
    1842:	58 c0       	rjmp	.+176    	; 0x18f4 <fnd_display+0xd6>
    1844:	85 30       	cpi	r24, 0x05	; 5
    1846:	09 f0       	breq	.+2      	; 0x184a <fnd_display+0x2c>
    1848:	a4 c0       	rjmp	.+328    	; 0x1992 <fnd_display+0x174>
    184a:	70 c0       	rjmp	.+224    	; 0x192c <fnd_display+0x10e>
	{
	case 1:
		sbi(DDRB , HC595_DATA_1);	sbi(DDRB , HC595_CLK_1);	sbi(DDRB , HC595_LATCH_1);	//fnd port IO setup
    184c:	b8 9a       	sbi	0x17, 0	; 23
    184e:	b9 9a       	sbi	0x17, 1	; 23
    1850:	ba 9a       	sbi	0x17, 2	; 23
		cbi(PORTB,HC595_LATCH_1);		//LATCH clear
    1852:	c2 98       	cbi	0x18, 2	; 24
    1854:	80 e0       	ldi	r24, 0x00	; 0
    1856:	90 e0       	ldi	r25, 0x00	; 0
			
		for(i=0;i<8;i++){
			if((data<<i) & 0x80){		//left shift
    1858:	30 e0       	ldi	r19, 0x00	; 0
    185a:	a9 01       	movw	r20, r18
    185c:	08 2e       	mov	r0, r24
    185e:	02 c0       	rjmp	.+4      	; 0x1864 <fnd_display+0x46>
    1860:	44 0f       	add	r20, r20
    1862:	55 1f       	adc	r21, r21
    1864:	0a 94       	dec	r0
    1866:	e2 f7       	brpl	.-8      	; 0x1860 <fnd_display+0x42>
    1868:	47 ff       	sbrs	r20, 7
    186a:	02 c0       	rjmp	.+4      	; 0x1870 <fnd_display+0x52>
				sbi(PORTB,HC595_DATA_1);
    186c:	c0 9a       	sbi	0x18, 0	; 24
    186e:	01 c0       	rjmp	.+2      	; 0x1872 <fnd_display+0x54>
				NOP();
			}else{
				cbi(PORTB,HC595_DATA_1);
    1870:	c0 98       	cbi	0x18, 0	; 24
				NOP();
    1872:	00 00       	nop
			}
			
			sbi(PORTB,HC595_CLK_1);	
    1874:	c1 9a       	sbi	0x18, 1	; 24
			cbi(PORTB,HC595_CLK_1);
    1876:	c1 98       	cbi	0x18, 1	; 24
    1878:	01 96       	adiw	r24, 0x01	; 1
	{
	case 1:
		sbi(DDRB , HC595_DATA_1);	sbi(DDRB , HC595_CLK_1);	sbi(DDRB , HC595_LATCH_1);	//fnd port IO setup
		cbi(PORTB,HC595_LATCH_1);		//LATCH clear
			
		for(i=0;i<8;i++){
    187a:	88 30       	cpi	r24, 0x08	; 8
    187c:	91 05       	cpc	r25, r1
    187e:	69 f7       	brne	.-38     	; 0x185a <fnd_display+0x3c>
			sbi(PORTB,HC595_CLK_1);	
			cbi(PORTB,HC595_CLK_1);
		
		}

		sbi(PORTB,HC595_LATCH_1);	 //LATCH set
    1880:	c2 9a       	sbi	0x18, 2	; 24
		break;
    1882:	08 95       	ret

	case 2:
		sbi(DDRD , HC595_DATA_2);	sbi(DDRD , HC595_CLK_2);	sbi(DDRD , HC595_LATCH_2);	//fnd port IO setup
    1884:	88 9a       	sbi	0x11, 0	; 17
    1886:	89 9a       	sbi	0x11, 1	; 17
    1888:	8a 9a       	sbi	0x11, 2	; 17
		cbi(PORTD,HC595_LATCH_2);		//LATCH clear
    188a:	92 98       	cbi	0x12, 2	; 18
    188c:	80 e0       	ldi	r24, 0x00	; 0
    188e:	90 e0       	ldi	r25, 0x00	; 0

		for(i=0;i<8;i++){
			if((data<<i) & 0x80){		//left shift
    1890:	30 e0       	ldi	r19, 0x00	; 0
    1892:	a9 01       	movw	r20, r18
    1894:	08 2e       	mov	r0, r24
    1896:	02 c0       	rjmp	.+4      	; 0x189c <fnd_display+0x7e>
    1898:	44 0f       	add	r20, r20
    189a:	55 1f       	adc	r21, r21
    189c:	0a 94       	dec	r0
    189e:	e2 f7       	brpl	.-8      	; 0x1898 <fnd_display+0x7a>
    18a0:	47 ff       	sbrs	r20, 7
    18a2:	02 c0       	rjmp	.+4      	; 0x18a8 <fnd_display+0x8a>
				sbi(PORTD,HC595_DATA_2);
    18a4:	90 9a       	sbi	0x12, 0	; 18
    18a6:	01 c0       	rjmp	.+2      	; 0x18aa <fnd_display+0x8c>
				NOP();
			}else{
				cbi(PORTD,HC595_DATA_2);
    18a8:	90 98       	cbi	0x12, 0	; 18
				NOP();
    18aa:	00 00       	nop
			}					
	
			sbi(PORTD,HC595_CLK_2);	
    18ac:	91 9a       	sbi	0x12, 1	; 18
			cbi(PORTD,HC595_CLK_2);
    18ae:	91 98       	cbi	0x12, 1	; 18
    18b0:	01 96       	adiw	r24, 0x01	; 1

	case 2:
		sbi(DDRD , HC595_DATA_2);	sbi(DDRD , HC595_CLK_2);	sbi(DDRD , HC595_LATCH_2);	//fnd port IO setup
		cbi(PORTD,HC595_LATCH_2);		//LATCH clear

		for(i=0;i<8;i++){
    18b2:	88 30       	cpi	r24, 0x08	; 8
    18b4:	91 05       	cpc	r25, r1
    18b6:	69 f7       	brne	.-38     	; 0x1892 <fnd_display+0x74>
			sbi(PORTD,HC595_CLK_2);	
			cbi(PORTD,HC595_CLK_2);

		}

		sbi(PORTD,HC595_LATCH_2);	 //LATCH set
    18b8:	92 9a       	sbi	0x12, 2	; 18
		break;
    18ba:	08 95       	ret

	case 3:
		sbi(DDRD , HC595_DATA_3);	sbi(DDRD , HC595_CLK_3);	sbi(DDRD , HC595_LATCH_3);	//fnd port IO setup
    18bc:	8c 9a       	sbi	0x11, 4	; 17
    18be:	8d 9a       	sbi	0x11, 5	; 17
    18c0:	8e 9a       	sbi	0x11, 6	; 17
		cbi(PORTD,HC595_LATCH_3);		//LATCH clear
    18c2:	96 98       	cbi	0x12, 6	; 18
    18c4:	80 e0       	ldi	r24, 0x00	; 0
    18c6:	90 e0       	ldi	r25, 0x00	; 0

		for(i=0;i<8;i++){
			if((data<<i) & 0x80){		//left shift
    18c8:	30 e0       	ldi	r19, 0x00	; 0
    18ca:	a9 01       	movw	r20, r18
    18cc:	08 2e       	mov	r0, r24
    18ce:	02 c0       	rjmp	.+4      	; 0x18d4 <fnd_display+0xb6>
    18d0:	44 0f       	add	r20, r20
    18d2:	55 1f       	adc	r21, r21
    18d4:	0a 94       	dec	r0
    18d6:	e2 f7       	brpl	.-8      	; 0x18d0 <fnd_display+0xb2>
    18d8:	47 ff       	sbrs	r20, 7
    18da:	02 c0       	rjmp	.+4      	; 0x18e0 <fnd_display+0xc2>
				sbi(PORTD,HC595_DATA_3);
    18dc:	94 9a       	sbi	0x12, 4	; 18
    18de:	01 c0       	rjmp	.+2      	; 0x18e2 <fnd_display+0xc4>
				NOP();
			}else{
				cbi(PORTD,HC595_DATA_3);
    18e0:	94 98       	cbi	0x12, 4	; 18
				NOP();
    18e2:	00 00       	nop
			}

			sbi(PORTD,HC595_CLK_3);	
    18e4:	95 9a       	sbi	0x12, 5	; 18
			cbi(PORTD,HC595_CLK_3);
    18e6:	95 98       	cbi	0x12, 5	; 18
    18e8:	01 96       	adiw	r24, 0x01	; 1

	case 3:
		sbi(DDRD , HC595_DATA_3);	sbi(DDRD , HC595_CLK_3);	sbi(DDRD , HC595_LATCH_3);	//fnd port IO setup
		cbi(PORTD,HC595_LATCH_3);		//LATCH clear

		for(i=0;i<8;i++){
    18ea:	88 30       	cpi	r24, 0x08	; 8
    18ec:	91 05       	cpc	r25, r1
    18ee:	69 f7       	brne	.-38     	; 0x18ca <fnd_display+0xac>
			sbi(PORTD,HC595_CLK_3);	
			cbi(PORTD,HC595_CLK_3);

		}

		sbi(PORTD,HC595_LATCH_3);	 //LATCH set
    18f0:	96 9a       	sbi	0x12, 6	; 18
		break;
    18f2:	08 95       	ret

	case 4:
		sbi(DDRE , HC595_DATA_4);	sbi(DDRE , HC595_CLK_4);	sbi(DDRE , HC595_LATCH_4);	//fnd port IO setup
    18f4:	10 9a       	sbi	0x02, 0	; 2
    18f6:	11 9a       	sbi	0x02, 1	; 2
    18f8:	12 9a       	sbi	0x02, 2	; 2
		cbi(PORTE,HC595_LATCH_4);		//LATCH clear
    18fa:	1a 98       	cbi	0x03, 2	; 3
    18fc:	80 e0       	ldi	r24, 0x00	; 0
    18fe:	90 e0       	ldi	r25, 0x00	; 0

		for(i=0;i<8;i++){
			if((data<<i) & 0x80){		//left shift
    1900:	30 e0       	ldi	r19, 0x00	; 0
    1902:	a9 01       	movw	r20, r18
    1904:	08 2e       	mov	r0, r24
    1906:	02 c0       	rjmp	.+4      	; 0x190c <fnd_display+0xee>
    1908:	44 0f       	add	r20, r20
    190a:	55 1f       	adc	r21, r21
    190c:	0a 94       	dec	r0
    190e:	e2 f7       	brpl	.-8      	; 0x1908 <fnd_display+0xea>
    1910:	47 ff       	sbrs	r20, 7
    1912:	02 c0       	rjmp	.+4      	; 0x1918 <fnd_display+0xfa>
				sbi(PORTE,HC595_DATA_4);
    1914:	18 9a       	sbi	0x03, 0	; 3
    1916:	01 c0       	rjmp	.+2      	; 0x191a <fnd_display+0xfc>
				NOP();
			}else{
				cbi(PORTE,HC595_DATA_4);
    1918:	18 98       	cbi	0x03, 0	; 3
				NOP();
    191a:	00 00       	nop
			}

			sbi(PORTE,HC595_CLK_4);	
    191c:	19 9a       	sbi	0x03, 1	; 3
			cbi(PORTE,HC595_CLK_4);
    191e:	19 98       	cbi	0x03, 1	; 3
    1920:	01 96       	adiw	r24, 0x01	; 1

	case 4:
		sbi(DDRE , HC595_DATA_4);	sbi(DDRE , HC595_CLK_4);	sbi(DDRE , HC595_LATCH_4);	//fnd port IO setup
		cbi(PORTE,HC595_LATCH_4);		//LATCH clear

		for(i=0;i<8;i++){
    1922:	88 30       	cpi	r24, 0x08	; 8
    1924:	91 05       	cpc	r25, r1
    1926:	69 f7       	brne	.-38     	; 0x1902 <fnd_display+0xe4>
			sbi(PORTE,HC595_CLK_4);	
			cbi(PORTE,HC595_CLK_4);

		}

		sbi(PORTE,HC595_LATCH_4);	 //LATCH set
    1928:	1a 9a       	sbi	0x03, 2	; 3
		break;
    192a:	08 95       	ret

	case 5:
		sbi(DDRE , HC595_DATA_5);	sbi(DDRG , HC595_CLK_5);	sbi(DDRG , HC595_LATCH_5);	//fnd port IO setup
    192c:	17 9a       	sbi	0x02, 7	; 2
    192e:	80 91 64 00 	lds	r24, 0x0064
    1932:	88 60       	ori	r24, 0x08	; 8
    1934:	80 93 64 00 	sts	0x0064, r24
    1938:	80 91 64 00 	lds	r24, 0x0064
    193c:	80 61       	ori	r24, 0x10	; 16
    193e:	80 93 64 00 	sts	0x0064, r24
		cbi(PORTG,HC595_LATCH_5);		//LATCH clear
    1942:	80 91 65 00 	lds	r24, 0x0065
    1946:	8f 7e       	andi	r24, 0xEF	; 239
    1948:	80 93 65 00 	sts	0x0065, r24
    194c:	80 e0       	ldi	r24, 0x00	; 0
    194e:	90 e0       	ldi	r25, 0x00	; 0

		for(i=0;i<8;i++){
			if((data<<i) & 0x80){		//left shift
    1950:	30 e0       	ldi	r19, 0x00	; 0
    1952:	a9 01       	movw	r20, r18
    1954:	08 2e       	mov	r0, r24
    1956:	02 c0       	rjmp	.+4      	; 0x195c <fnd_display+0x13e>
    1958:	44 0f       	add	r20, r20
    195a:	55 1f       	adc	r21, r21
    195c:	0a 94       	dec	r0
    195e:	e2 f7       	brpl	.-8      	; 0x1958 <fnd_display+0x13a>
    1960:	47 ff       	sbrs	r20, 7
    1962:	02 c0       	rjmp	.+4      	; 0x1968 <fnd_display+0x14a>
				sbi(PORTE,HC595_DATA_5);
    1964:	1f 9a       	sbi	0x03, 7	; 3
    1966:	01 c0       	rjmp	.+2      	; 0x196a <fnd_display+0x14c>
				NOP();
			}else{
				cbi(PORTE,HC595_DATA_5);
    1968:	1f 98       	cbi	0x03, 7	; 3
				NOP();
    196a:	00 00       	nop
			}

			sbi(PORTG,HC595_CLK_5);	
    196c:	40 91 65 00 	lds	r20, 0x0065
    1970:	48 60       	ori	r20, 0x08	; 8
    1972:	40 93 65 00 	sts	0x0065, r20
			cbi(PORTG,HC595_CLK_5);
    1976:	40 91 65 00 	lds	r20, 0x0065
    197a:	47 7f       	andi	r20, 0xF7	; 247
    197c:	40 93 65 00 	sts	0x0065, r20
    1980:	01 96       	adiw	r24, 0x01	; 1

	case 5:
		sbi(DDRE , HC595_DATA_5);	sbi(DDRG , HC595_CLK_5);	sbi(DDRG , HC595_LATCH_5);	//fnd port IO setup
		cbi(PORTG,HC595_LATCH_5);		//LATCH clear

		for(i=0;i<8;i++){
    1982:	88 30       	cpi	r24, 0x08	; 8
    1984:	91 05       	cpc	r25, r1
    1986:	29 f7       	brne	.-54     	; 0x1952 <fnd_display+0x134>
			sbi(PORTG,HC595_CLK_5);	
			cbi(PORTG,HC595_CLK_5);

		}

		sbi(PORTG,HC595_LATCH_5);	 //LATCH set
    1988:	80 91 65 00 	lds	r24, 0x0065
    198c:	80 61       	ori	r24, 0x10	; 16
    198e:	80 93 65 00 	sts	0x0065, r24
    1992:	08 95       	ret

00001994 <main>:
#include "ModuleFunction.h"


void main(void)
{
	Initialize();
    1994:	0e 94 63 08 	call	0x10c6	; 0x10c6 <Initialize>

	LcdDisplay("hello","world");
    1998:	80 e0       	ldi	r24, 0x00	; 0
    199a:	91 e0       	ldi	r25, 0x01	; 1
    199c:	66 e0       	ldi	r22, 0x06	; 6
    199e:	71 e0       	ldi	r23, 0x01	; 1
    19a0:	0e 94 03 0a 	call	0x1406	; 0x1406 <LcdDisplay>

}
    19a4:	08 95       	ret

000019a6 <_exit>:
    19a6:	f8 94       	cli

000019a8 <__stop_program>:
    19a8:	ff cf       	rjmp	.-2      	; 0x19a8 <__stop_program>
